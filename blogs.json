{"status":"ok","feed":{"url":"https://medium.com/feed/@sanjayofficial94","title":"Stories by Sanjay Mehta on Medium","link":"https://medium.com/@sanjayofficial94?source=rss-dfd30b357e8c------2","author":"","description":"Stories by Sanjay Mehta on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*3QNRzQCxKLSvicXeH5ybRQ.jpeg"},"items":[{"title":"Principals of Reliable Applications","pubDate":"2024-01-12 05:35:35","link":"https://medium.com/@sanjayofficial94/principals-of-reliable-applications-64970c07610e?source=rss-dfd30b357e8c------2","guid":"https://medium.com/p/64970c07610e","author":"Sanjay Mehta","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*RNRX4iZtAZ_Qo_gQzfeSOQ.jpeg\"></figure><blockquote>A reliable distributed system is composed of reliable applications.</blockquote>\n<p>Reliable applications have several positive properties, and these properties help us when we\u2019re building distributed systems, but they\u2019re also good just on their own. Some of these properties are <strong>idempotence</strong>, <strong>immutability</strong>, <strong>location independence</strong>, and <strong>versioning</strong>.</p>\n<h4><strong>Idempotence</strong></h4>\n<blockquote>Idempotence is a property that helps us to tolerate unreliable networks.</blockquote>\n<p>When the network is unreliable, the client might have to retry, and an idempotent application won\u2019t duplicate the effect if it receives a duplicate message.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/889/1*FhoVeWOhAoS2L3V2mGyQzQ.png\"></figure><p><strong>Problems with\u00a0CRUD</strong></p>\n<p><strong>CRUD</strong> stands for create, read, update, and delete. These are four operations that you can use in order to create and modify entities within your system. The default position for mapping these four operations onto a RESTful API is to map <strong>create</strong> to <strong>POST</strong>, <strong>read</strong> to <strong>GET</strong>, <strong>update</strong> to <strong>PUT</strong>, and <strong>delete</strong>, of course, to\u00a0<strong>DELETE</strong>.</p>\n<p>Now the problem with that default mapping has to do with idempotence. In REST, the PUT and DELETE verbs are specified to be <strong>idempotent</strong>, but POST is not <strong>idempotent</strong>. An <strong>idempotent</strong> operation is one that will have no effect if it is received a second time. So, for example, if you were to PUT some contents to a resource and then repeat that PUT, the second one wouldn\u2019t change the contents. POST, however, is not guaranteed to be idempotent by default. That means if you were to POST to a resource twice, you would end up with two different entities.</p>\n<p>Remember, the <strong>network</strong> is <strong>unreliable</strong>. Let\u2019s see what happens with a typical API when the client has to retry. Let\u2019s say that the client wants to create a new employee, and so they\u2019re going to POST to the /employees resource. The first time the server is going to insert into the Employee table and then come up with the new unique ID of 37. This is an <strong>auto\u2011incrementing ID</strong> that the database generates upon <strong>INSERT</strong>. The server then responds with a 201 Created and the URL /employees/37. But remember, the network is unreliable. So what if the client never hears about this 201? The client has no choice but to try again. Now whether that\u2019s the user clicking submit twice or something within the application performing a retry, it doesn\u2019t matter. The application is going to end up sending another <strong>POST</strong> to /employees. On that <strong>second</strong> <strong>POST</strong>, the server is also going to do an <strong>INSERT</strong> into the Employee table, but this time it\u2019s going to come back with the ID of 38. So the second time we return a 201 CREATED /employees/38. This operation is not <strong>idempotent</strong> because upon the second receipt of the same message, the server duplicated the effect. It ends up inserted two\u00a0rows.</p>\n<p>In order to behave in an idempotent manner, it needs to determine whether the client intended to create a second employee or if that was just a duplicate message. But in this particular API, every creation looks exactly the same. And so the server can\u2019t tell the difference between an intentional creation of a second object and a\u00a0retry.</p>\n<p><strong>The solution</strong> is to introduce a <strong>client\u2011side ID</strong>. You see, if the client knows the ID of the object before it\u2019s created, then the server can tell the difference between the creation of a new object and a duplicate message. Duplicate messages will carry the same IDs as the original. And now if the client is supposed to know the ID before creation, we can\u2019t wait for the server to run an INSERT on the database in order to generate the ID. And so we have to use a different ID than the auto incrementing key in the database. In this case, we chooses to use a GUID as the ID of a employee. we\u2019ll represent this as an alternate key in the database. And then, we\u2019ll redesign the API to look like this. To create a new employee, the client will POST to /employees/abc\u2011123, the GUID of the employee that they intend to create. Upon first receipt of this message, the server will see that that alternate key does not exist within the Employee table. It will therefore insert the row and then return a 201 CREATED /employees/abc\u2011123. The table still has a primary key, which is an auto\u2011incrementing ID, but that ID is never returned through the API. But let\u2019s suppose that our unreliable network has dropped that 201 response message, and so the client retries. The client still has the ID that it intends to create, and so it sends a POST to /employees/abc\u2011123. This time when the server sees that message, it can tell that that alternate key already exists within the Employee table. It therefore does not insert an additional row, but it still returns 201 CREATED /employees/abc\u2011123. And so with these two changes to the API design and to the database design, we will be able to implement <strong>idempotence</strong> on the server\u00a0side.</p>\n<h4>Immutability</h4>\n<blockquote>Immutability is good because that means that we keep a record of everything that happened within the system. And a beautiful application won\u2019t destroy data by overwriting it or deleting\u00a0it.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/1*uZfdZ0ca96tmQAl8qUPumg.png\"></figure><p><strong>Immutability</strong> as a default has several different advantages, some technical and some business advantages. One business advantage is that immutability gives you a reliable <strong>audit log</strong>. If you can\u2019t change or delete the information that\u2019s in the database, then every decision becomes an insert. Every row is an entry in your audit log, capturing the intent of the user. Another advantage on both the business and the technical side is that immutable systems do not destroy data. Immutable records cannot be deleted, and they cannot be updated where updates would replace or destroy the information that used to be in that record. But the most important technical advantage of immutability is that it preserves metadata. Preserving metadata is especially important in a distributed system. <strong>Metadata</strong> reveals which information a certain node has received in the past and therefore can control how it reacts to new information in the future. Metadata allows remote peers to converge and become eventually consistent.</p>\n<p><strong>Immutability</strong> is a great default for distributed systems. we will choose two very simple patterns to begin with. The first one is <strong>snapshots</strong>. Rather than keeping the mutable state of an employees within the Employee table, we are going to keep a separate snapshot table, and this will be called Employee Description table. Every time a user wants to change the description of a <strong>employee</strong>, they will end up inserting a row into the <strong>snapshot</strong> table. That will simulate <strong>updates</strong>, but what about <strong>deletes</strong>? Well for that, we will use the <strong>tombstone</strong> pattern. Instead of actually deleting the employee record, we\u2019ll insert a new record into the Employee Removed table. The presence of this employee removed child record indicates that the employee has been deleted. Both Employee Description and Employee Removed table have a employeeID foreign key, and they also contain a date. All tables in this system have an alternate key, and these two are no exception. The alternate keys of these two tables are the EmployeeID and either the date modified or the date\u00a0removed.</p>\n<h4>Location Independence</h4>\n<blockquote>Distributed systems are made up of different applications that are deployed to different locations. If the behavior of an application is dependent upon where it\u2019s deployed, its location, then that causes problems while composing it into a distributed system.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/662/1*tQVIotj6AQfMiogK3KEPXw.jpeg\"></figure><p>The <strong>third</strong> property that we want in a <strong>reliable application</strong> is <strong>location</strong> <strong>independence</strong>. <strong>Location independence</strong> implies that an application\u2019s behavior does not depend upon its location. In other words, if you were to deploy an application to multiple locations and then send the same message to each instance, they would all produce the same behavior. This might seem like a property that we get almost for free, but we\u2019ve already seen one example of an application design pattern that is not location independent, and that is the use of <strong>auto\u2011incrementing IDs</strong>. An <strong>auto\u2011incrementing ID</strong> generated on one database is only good at that one database. As an identifier for a row, it\u2019s dependent upon that location. If we were to insert the same object into databases at different locations, they would each come up with different identifiers. Where still, databases in different locations will come up with the same identifier for different objects.</p>\n<p>The solution to the above problem is to use <strong>hash</strong>, which is <strong>great location independent identifier</strong>. When hashes are used as identifiers, the pattern is known as <strong>content\u2011addressed storage</strong>. <strong>Content\u2011address storage</strong> means that you\u2019re using the content to identify itself. It works by computing the hash of the content that you want to store and then storing that in a location addressed by that hash. Now if somebody wants to refer to that object, they simply reference it by its hash. Unlike an auto\u2011incremented ID, content\u2011addressed storage is location independent. Every single instance of the application will compute the same hash for a given object. The hash depends only upon the content and not upon anything else that might happen to be stored at that location. Furthermore, different locations storing different objects are very unlikely to produce the same hash. Hash collisions are vanishingly rare.</p>\n<p>Now, if you\u2019re thinking, that\u2019s a really strange way to identify an object, well, you\u2019re probably already familiar with an existing implementation of content\u2011addressed storage. <strong>Docker</strong>, for example, uses content\u2011addressed storage in order to identify images. The identity of a Docker image is the hash of the steps that it took to produce it. You might also be familiar with <strong>Git</strong>. Git uses the SHA\u20111 hash of the commit as its identity.</p>\n<h4>Versioning</h4>\n<blockquote>Things change over time, and a well\u2011versioned application will tolerate those changes over\u00a0time.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/1*Osrcf9vVFwYo6RJ3_ShPMA.png\"></figure><p>The final property that we wants to ensure that our reliable application has is proper <strong>versioning</strong>. we know that the <strong>network</strong> is not <strong>homogenous</strong>, and that means that different versions or applications are going to be deployed across different locations at different times. As this happens, we wants to make sure that we maintains the contract across those changes, and so we are going to want to make sure that we puts a good versioning strategy in place from the beginning.</p>\n<p>To consider how to version an application, we are going to break it down into <strong>three</strong> large components. <strong>An application consists of code, data, and an API</strong>. The <strong>code</strong> is by far the easiest of these three to version. We can use tools like source control and continuous integration and continuous delivery pipelines in order to make sure that we\u2019re delivering a consistent set of application code. And when the code is downloaded in pieces to the browser, we can use content\u2011addressed storage in order to make sure that all of the artifacts are consistent with one another. While code versioning is easy, data versioning is a little bit more tricky. <strong>Data</strong> will be stored on each of the different nodes, and we\u2019ll have to migrate that data to the next version in order to evolve the application. Since we are going to favor creating new tables, rather than adding columns to existing tables and finally, while data might be tricky, <strong>API versioning</strong> is downright difficult. Here, we consider the API of an application to be the endpoints that you can call, as well as the messages that you send and receive. API management is really application lifecycle management, because application interfaces evolve over time. There is no agreed\u2011upon best practice for evolving an\u00a0API.</p>\n<p>We can use the <strong>URL strategy</strong> in order to indicate the version of the API. As the API evolves, the path changes to include a new version number. Another strategy would be to use <strong>content types</strong> in order to version APIs. A client would use an application\u2011defined Accept header, and the server supply an application\u2011defined Content\u2011Type. While this is more in keeping with the design philosophy of REST, it\u2019s a bit more difficult to implement. And <strong>the final versioning strategy is to simply avoid versioning</strong>, and while this might at first seem like an irresponsible strategy, it\u2019s precisely the strategy that <strong>GraphQL</strong> uses. <strong>GraphQL</strong> favors version-less APIs and allows the client to choose what the structure of their response.</p>\n<h4>Summary</h4>\n<p>These <strong>four properties</strong> are not the default. They don\u2019t come with any application template. It requires a bit more effort and buy\u2011in from application development teams, but the results are well worth it. By having these practices in place ahead of time, we know that each of the applications that our team builds are going to be <strong>good citizens of a distributed system</strong>. If you don\u2019t need to build distributed systems, then stop right here. Apply these principles, and your applications will be more reliable.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=64970c07610e\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*RNRX4iZtAZ_Qo_gQzfeSOQ.jpeg\"></figure><blockquote>A reliable distributed system is composed of reliable applications.</blockquote>\n<p>Reliable applications have several positive properties, and these properties help us when we\u2019re building distributed systems, but they\u2019re also good just on their own. Some of these properties are <strong>idempotence</strong>, <strong>immutability</strong>, <strong>location independence</strong>, and <strong>versioning</strong>.</p>\n<h4><strong>Idempotence</strong></h4>\n<blockquote>Idempotence is a property that helps us to tolerate unreliable networks.</blockquote>\n<p>When the network is unreliable, the client might have to retry, and an idempotent application won\u2019t duplicate the effect if it receives a duplicate message.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/889/1*FhoVeWOhAoS2L3V2mGyQzQ.png\"></figure><p><strong>Problems with\u00a0CRUD</strong></p>\n<p><strong>CRUD</strong> stands for create, read, update, and delete. These are four operations that you can use in order to create and modify entities within your system. The default position for mapping these four operations onto a RESTful API is to map <strong>create</strong> to <strong>POST</strong>, <strong>read</strong> to <strong>GET</strong>, <strong>update</strong> to <strong>PUT</strong>, and <strong>delete</strong>, of course, to\u00a0<strong>DELETE</strong>.</p>\n<p>Now the problem with that default mapping has to do with idempotence. In REST, the PUT and DELETE verbs are specified to be <strong>idempotent</strong>, but POST is not <strong>idempotent</strong>. An <strong>idempotent</strong> operation is one that will have no effect if it is received a second time. So, for example, if you were to PUT some contents to a resource and then repeat that PUT, the second one wouldn\u2019t change the contents. POST, however, is not guaranteed to be idempotent by default. That means if you were to POST to a resource twice, you would end up with two different entities.</p>\n<p>Remember, the <strong>network</strong> is <strong>unreliable</strong>. Let\u2019s see what happens with a typical API when the client has to retry. Let\u2019s say that the client wants to create a new employee, and so they\u2019re going to POST to the /employees resource. The first time the server is going to insert into the Employee table and then come up with the new unique ID of 37. This is an <strong>auto\u2011incrementing ID</strong> that the database generates upon <strong>INSERT</strong>. The server then responds with a 201 Created and the URL /employees/37. But remember, the network is unreliable. So what if the client never hears about this 201? The client has no choice but to try again. Now whether that\u2019s the user clicking submit twice or something within the application performing a retry, it doesn\u2019t matter. The application is going to end up sending another <strong>POST</strong> to /employees. On that <strong>second</strong> <strong>POST</strong>, the server is also going to do an <strong>INSERT</strong> into the Employee table, but this time it\u2019s going to come back with the ID of 38. So the second time we return a 201 CREATED /employees/38. This operation is not <strong>idempotent</strong> because upon the second receipt of the same message, the server duplicated the effect. It ends up inserted two\u00a0rows.</p>\n<p>In order to behave in an idempotent manner, it needs to determine whether the client intended to create a second employee or if that was just a duplicate message. But in this particular API, every creation looks exactly the same. And so the server can\u2019t tell the difference between an intentional creation of a second object and a\u00a0retry.</p>\n<p><strong>The solution</strong> is to introduce a <strong>client\u2011side ID</strong>. You see, if the client knows the ID of the object before it\u2019s created, then the server can tell the difference between the creation of a new object and a duplicate message. Duplicate messages will carry the same IDs as the original. And now if the client is supposed to know the ID before creation, we can\u2019t wait for the server to run an INSERT on the database in order to generate the ID. And so we have to use a different ID than the auto incrementing key in the database. In this case, we chooses to use a GUID as the ID of a employee. we\u2019ll represent this as an alternate key in the database. And then, we\u2019ll redesign the API to look like this. To create a new employee, the client will POST to /employees/abc\u2011123, the GUID of the employee that they intend to create. Upon first receipt of this message, the server will see that that alternate key does not exist within the Employee table. It will therefore insert the row and then return a 201 CREATED /employees/abc\u2011123. The table still has a primary key, which is an auto\u2011incrementing ID, but that ID is never returned through the API. But let\u2019s suppose that our unreliable network has dropped that 201 response message, and so the client retries. The client still has the ID that it intends to create, and so it sends a POST to /employees/abc\u2011123. This time when the server sees that message, it can tell that that alternate key already exists within the Employee table. It therefore does not insert an additional row, but it still returns 201 CREATED /employees/abc\u2011123. And so with these two changes to the API design and to the database design, we will be able to implement <strong>idempotence</strong> on the server\u00a0side.</p>\n<h4>Immutability</h4>\n<blockquote>Immutability is good because that means that we keep a record of everything that happened within the system. And a beautiful application won\u2019t destroy data by overwriting it or deleting\u00a0it.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/1*uZfdZ0ca96tmQAl8qUPumg.png\"></figure><p><strong>Immutability</strong> as a default has several different advantages, some technical and some business advantages. One business advantage is that immutability gives you a reliable <strong>audit log</strong>. If you can\u2019t change or delete the information that\u2019s in the database, then every decision becomes an insert. Every row is an entry in your audit log, capturing the intent of the user. Another advantage on both the business and the technical side is that immutable systems do not destroy data. Immutable records cannot be deleted, and they cannot be updated where updates would replace or destroy the information that used to be in that record. But the most important technical advantage of immutability is that it preserves metadata. Preserving metadata is especially important in a distributed system. <strong>Metadata</strong> reveals which information a certain node has received in the past and therefore can control how it reacts to new information in the future. Metadata allows remote peers to converge and become eventually consistent.</p>\n<p><strong>Immutability</strong> is a great default for distributed systems. we will choose two very simple patterns to begin with. The first one is <strong>snapshots</strong>. Rather than keeping the mutable state of an employees within the Employee table, we are going to keep a separate snapshot table, and this will be called Employee Description table. Every time a user wants to change the description of a <strong>employee</strong>, they will end up inserting a row into the <strong>snapshot</strong> table. That will simulate <strong>updates</strong>, but what about <strong>deletes</strong>? Well for that, we will use the <strong>tombstone</strong> pattern. Instead of actually deleting the employee record, we\u2019ll insert a new record into the Employee Removed table. The presence of this employee removed child record indicates that the employee has been deleted. Both Employee Description and Employee Removed table have a employeeID foreign key, and they also contain a date. All tables in this system have an alternate key, and these two are no exception. The alternate keys of these two tables are the EmployeeID and either the date modified or the date\u00a0removed.</p>\n<h4>Location Independence</h4>\n<blockquote>Distributed systems are made up of different applications that are deployed to different locations. If the behavior of an application is dependent upon where it\u2019s deployed, its location, then that causes problems while composing it into a distributed system.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/662/1*tQVIotj6AQfMiogK3KEPXw.jpeg\"></figure><p>The <strong>third</strong> property that we want in a <strong>reliable application</strong> is <strong>location</strong> <strong>independence</strong>. <strong>Location independence</strong> implies that an application\u2019s behavior does not depend upon its location. In other words, if you were to deploy an application to multiple locations and then send the same message to each instance, they would all produce the same behavior. This might seem like a property that we get almost for free, but we\u2019ve already seen one example of an application design pattern that is not location independent, and that is the use of <strong>auto\u2011incrementing IDs</strong>. An <strong>auto\u2011incrementing ID</strong> generated on one database is only good at that one database. As an identifier for a row, it\u2019s dependent upon that location. If we were to insert the same object into databases at different locations, they would each come up with different identifiers. Where still, databases in different locations will come up with the same identifier for different objects.</p>\n<p>The solution to the above problem is to use <strong>hash</strong>, which is <strong>great location independent identifier</strong>. When hashes are used as identifiers, the pattern is known as <strong>content\u2011addressed storage</strong>. <strong>Content\u2011address storage</strong> means that you\u2019re using the content to identify itself. It works by computing the hash of the content that you want to store and then storing that in a location addressed by that hash. Now if somebody wants to refer to that object, they simply reference it by its hash. Unlike an auto\u2011incremented ID, content\u2011addressed storage is location independent. Every single instance of the application will compute the same hash for a given object. The hash depends only upon the content and not upon anything else that might happen to be stored at that location. Furthermore, different locations storing different objects are very unlikely to produce the same hash. Hash collisions are vanishingly rare.</p>\n<p>Now, if you\u2019re thinking, that\u2019s a really strange way to identify an object, well, you\u2019re probably already familiar with an existing implementation of content\u2011addressed storage. <strong>Docker</strong>, for example, uses content\u2011addressed storage in order to identify images. The identity of a Docker image is the hash of the steps that it took to produce it. You might also be familiar with <strong>Git</strong>. Git uses the SHA\u20111 hash of the commit as its identity.</p>\n<h4>Versioning</h4>\n<blockquote>Things change over time, and a well\u2011versioned application will tolerate those changes over\u00a0time.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/1*Osrcf9vVFwYo6RJ3_ShPMA.png\"></figure><p>The final property that we wants to ensure that our reliable application has is proper <strong>versioning</strong>. we know that the <strong>network</strong> is not <strong>homogenous</strong>, and that means that different versions or applications are going to be deployed across different locations at different times. As this happens, we wants to make sure that we maintains the contract across those changes, and so we are going to want to make sure that we puts a good versioning strategy in place from the beginning.</p>\n<p>To consider how to version an application, we are going to break it down into <strong>three</strong> large components. <strong>An application consists of code, data, and an API</strong>. The <strong>code</strong> is by far the easiest of these three to version. We can use tools like source control and continuous integration and continuous delivery pipelines in order to make sure that we\u2019re delivering a consistent set of application code. And when the code is downloaded in pieces to the browser, we can use content\u2011addressed storage in order to make sure that all of the artifacts are consistent with one another. While code versioning is easy, data versioning is a little bit more tricky. <strong>Data</strong> will be stored on each of the different nodes, and we\u2019ll have to migrate that data to the next version in order to evolve the application. Since we are going to favor creating new tables, rather than adding columns to existing tables and finally, while data might be tricky, <strong>API versioning</strong> is downright difficult. Here, we consider the API of an application to be the endpoints that you can call, as well as the messages that you send and receive. API management is really application lifecycle management, because application interfaces evolve over time. There is no agreed\u2011upon best practice for evolving an\u00a0API.</p>\n<p>We can use the <strong>URL strategy</strong> in order to indicate the version of the API. As the API evolves, the path changes to include a new version number. Another strategy would be to use <strong>content types</strong> in order to version APIs. A client would use an application\u2011defined Accept header, and the server supply an application\u2011defined Content\u2011Type. While this is more in keeping with the design philosophy of REST, it\u2019s a bit more difficult to implement. And <strong>the final versioning strategy is to simply avoid versioning</strong>, and while this might at first seem like an irresponsible strategy, it\u2019s precisely the strategy that <strong>GraphQL</strong> uses. <strong>GraphQL</strong> favors version-less APIs and allows the client to choose what the structure of their response.</p>\n<h4>Summary</h4>\n<p>These <strong>four properties</strong> are not the default. They don\u2019t come with any application template. It requires a bit more effort and buy\u2011in from application development teams, but the results are well worth it. By having these practices in place ahead of time, we know that each of the applications that our team builds are going to be <strong>good citizens of a distributed system</strong>. If you don\u2019t need to build distributed systems, then stop right here. Apply these principles, and your applications will be more reliable.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=64970c07610e\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["reliability","system-design-concepts","distributed-systems","idempotency","immutability"]},{"title":"Things to know about Java Collection","pubDate":"2021-12-11 16:03:30","link":"https://medium.com/@sanjayofficial94/things-to-know-about-java-collection-d5091a15aa07?source=rss-dfd30b357e8c------2","guid":"https://medium.com/p/d5091a15aa07","author":"Sanjay Mehta","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iyVbTnlkTGLVb-R6_Sz0aA.jpeg\"></figure><h3>1. ArrayList subList() method</h3>\n<p>As many of us know the <strong>subList()</strong> method of <strong>java.util.ArrayList</strong> class is used to return the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is\u00a0empty.)</p>\n<p>But, it not only returns the portion of the list, but it also returns a view of the portion of the list. Let\u2019s understand better with the help of\u00a0code!</p>\n<pre>List&lt;String&gt; namesList = new ArrayList&lt;&gt;();</pre>\n<pre>namesList.add(\"David\");<br>namesList.add(\"George\");<br>namesList.add(\"Anne\");<br>namesList.add(\"Bailey\");<br>namesList.add(\"Carol\");</pre>\n<pre>System.out.println(\"Original State of namesList : \"+namesList);</pre>\n<pre># Output of original List<br>Original State of namesList : [David, George, Anne, Bailey, Carol]</pre>\n<pre># Get a view of list from index 1 to 3<br>List&lt;String&gt; subList = namesList.subList(1, 4);</pre>\n<pre># Sort the elements in reverse order<br>subList.sort(Comparator.<em>reverseOrder</em>());</pre>\n<pre>System.out.println(\"Original State of namesList after sorting subList : \"+namesList);</pre>\n<pre># Output of original List<br>Original State of namesList after sorting subList : [David, George, Bailey, Anne, Carol]</pre>\n<p>The returned list is backed by the original list, so non-structural changes in the returned list are reflected in the original list, and vice-versa. The returned list supports all of the optional list operations.</p>\n<p>So, if you try to make any structural changes in the returned list by using methods like add and clear. you will get <strong>UnsupportedOperationException</strong>.</p>\n<h3>2. Arrays asList()\u00a0method</h3>\n<p>The List returned using Arrays.asList() method is a <strong>fixed-size <em>List</em></strong>, we can\u2019t <strong>add/remove elements</strong>.</p>\n<pre>String[] flowers = { \"Ageratum\", \"Allium\", \"Poppy\", \"Catmint\" };  List&lt;String&gt; flowerList = Arrays.asList(flowers);  </pre>\n<pre>flowerList.add(\"Celosia\"); // throws UnsupportedOperationException</pre>\n<p>The root of this <strong><em>Exception</em></strong> is that the returned object doesn\u2019t implement the <em>add() </em>operation since it isn\u2019t the same as <em>java.util.ArrayList.</em></p>\n<p>There are ways by which we can get the mutable list from <strong>Arrays.asList</strong> method.</p>\n<p>For instance, we can pass the return object of <strong>Arrays.asList</strong> method in the constructor of <strong>ArrayList</strong>, which will support the add and remove operations.</p>\n<pre>String[] flowers = { \"Ageratum\", \"Allium\", \"Poppy\", \"Catmint\" };  List&lt;String&gt; flowerList = new ArrayList&lt;&gt;(Arrays.asList(flowers));</pre>\n<h3><strong>3. Double Brace Initialization</strong></h3>\n<p>Double braces can be used for <strong>creating and initializing objects in a single Java expression</strong>.</p>\n<h4>Standard Approach:</h4>\n<p>Normally we initialize and populate a set as\u00a0follows:</p>\n<pre>Set&lt;String&gt; countries = new HashSet&lt;String&gt;();                     countries.add(\"India\");     <br>countries.add(\"USA\");<br>countries.add(\"USSR\");</pre>\n<p>As you can see in the above\u00a0code</p>\n<ol>\n<li>Create an instance of\u00a0<em>HashSet</em>\n</li>\n<li>Add countries to the\u00a0<em>HashSet</em>\n</li>\n</ol>\n<h4><strong>Using Double\u00a0Brace:</strong></h4>\n<p>We can actually combine the creation and initialization in a single statement; this is where we make use of double\u00a0braces:</p>\n<pre>Set&lt;String&gt; countries = new HashSet&lt;String&gt;() {{ <br><br>add(\"India\");            <br>add(\"USSR\");            <br>add(\"USA\");        <br><br>}};</pre>\n<p>As you can see in the above\u00a0code:</p>\n<ol>\n<li>Creating an anonymous inner class that extends\u00a0<em>HashSet</em>\n</li>\n<li>Providing an instance initialization block that invokes the add method and adds the country name to the\u00a0<em>HashSet</em>\n</li>\n</ol>\n<h4>Advantages of using Double\u00a0Brace:</h4>\n<ul>\n<li>Fewer lines of code compared to the native way of creation and initialization.</li>\n<li>The code is more readable.</li>\n<li>Creation initialization is done in the same expression.</li>\n</ul>\n<p>Thank you, for reading this post, hope you liked it please give applause.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d5091a15aa07\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iyVbTnlkTGLVb-R6_Sz0aA.jpeg\"></figure><h3>1. ArrayList subList() method</h3>\n<p>As many of us know the <strong>subList()</strong> method of <strong>java.util.ArrayList</strong> class is used to return the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is\u00a0empty.)</p>\n<p>But, it not only returns the portion of the list, but it also returns a view of the portion of the list. Let\u2019s understand better with the help of\u00a0code!</p>\n<pre>List&lt;String&gt; namesList = new ArrayList&lt;&gt;();</pre>\n<pre>namesList.add(\"David\");<br>namesList.add(\"George\");<br>namesList.add(\"Anne\");<br>namesList.add(\"Bailey\");<br>namesList.add(\"Carol\");</pre>\n<pre>System.out.println(\"Original State of namesList : \"+namesList);</pre>\n<pre># Output of original List<br>Original State of namesList : [David, George, Anne, Bailey, Carol]</pre>\n<pre># Get a view of list from index 1 to 3<br>List&lt;String&gt; subList = namesList.subList(1, 4);</pre>\n<pre># Sort the elements in reverse order<br>subList.sort(Comparator.<em>reverseOrder</em>());</pre>\n<pre>System.out.println(\"Original State of namesList after sorting subList : \"+namesList);</pre>\n<pre># Output of original List<br>Original State of namesList after sorting subList : [David, George, Bailey, Anne, Carol]</pre>\n<p>The returned list is backed by the original list, so non-structural changes in the returned list are reflected in the original list, and vice-versa. The returned list supports all of the optional list operations.</p>\n<p>So, if you try to make any structural changes in the returned list by using methods like add and clear. you will get <strong>UnsupportedOperationException</strong>.</p>\n<h3>2. Arrays asList()\u00a0method</h3>\n<p>The List returned using Arrays.asList() method is a <strong>fixed-size <em>List</em></strong>, we can\u2019t <strong>add/remove elements</strong>.</p>\n<pre>String[] flowers = { \"Ageratum\", \"Allium\", \"Poppy\", \"Catmint\" };  List&lt;String&gt; flowerList = Arrays.asList(flowers);  </pre>\n<pre>flowerList.add(\"Celosia\"); // throws UnsupportedOperationException</pre>\n<p>The root of this <strong><em>Exception</em></strong> is that the returned object doesn\u2019t implement the <em>add() </em>operation since it isn\u2019t the same as <em>java.util.ArrayList.</em></p>\n<p>There are ways by which we can get the mutable list from <strong>Arrays.asList</strong> method.</p>\n<p>For instance, we can pass the return object of <strong>Arrays.asList</strong> method in the constructor of <strong>ArrayList</strong>, which will support the add and remove operations.</p>\n<pre>String[] flowers = { \"Ageratum\", \"Allium\", \"Poppy\", \"Catmint\" };  List&lt;String&gt; flowerList = new ArrayList&lt;&gt;(Arrays.asList(flowers));</pre>\n<h3><strong>3. Double Brace Initialization</strong></h3>\n<p>Double braces can be used for <strong>creating and initializing objects in a single Java expression</strong>.</p>\n<h4>Standard Approach:</h4>\n<p>Normally we initialize and populate a set as\u00a0follows:</p>\n<pre>Set&lt;String&gt; countries = new HashSet&lt;String&gt;();                     countries.add(\"India\");     <br>countries.add(\"USA\");<br>countries.add(\"USSR\");</pre>\n<p>As you can see in the above\u00a0code</p>\n<ol>\n<li>Create an instance of\u00a0<em>HashSet</em>\n</li>\n<li>Add countries to the\u00a0<em>HashSet</em>\n</li>\n</ol>\n<h4><strong>Using Double\u00a0Brace:</strong></h4>\n<p>We can actually combine the creation and initialization in a single statement; this is where we make use of double\u00a0braces:</p>\n<pre>Set&lt;String&gt; countries = new HashSet&lt;String&gt;() {{ <br><br>add(\"India\");            <br>add(\"USSR\");            <br>add(\"USA\");        <br><br>}};</pre>\n<p>As you can see in the above\u00a0code:</p>\n<ol>\n<li>Creating an anonymous inner class that extends\u00a0<em>HashSet</em>\n</li>\n<li>Providing an instance initialization block that invokes the add method and adds the country name to the\u00a0<em>HashSet</em>\n</li>\n</ol>\n<h4>Advantages of using Double\u00a0Brace:</h4>\n<ul>\n<li>Fewer lines of code compared to the native way of creation and initialization.</li>\n<li>The code is more readable.</li>\n<li>Creation initialization is done in the same expression.</li>\n</ul>\n<p>Thank you, for reading this post, hope you liked it please give applause.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d5091a15aa07\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["java","technology","software-engineering","collections-framework","software-development"]},{"title":"It\u2019s all about RxJS Subject","pubDate":"2021-09-18 09:45:26","link":"https://medium.com/@sanjayofficial94/its-all-about-rxjs-subject-f749e09b73ae?source=rss-dfd30b357e8c------2","guid":"https://medium.com/p/f749e09b73ae","author":"Sanjay Mehta","thumbnail":"","description":"\n<blockquote>A Subject is like an Observable, but can multicast to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*6KEtzMVVR5a7KqOL\"></figure><p><strong>Every Subject is an Observable</strong>. You can subscribe to a Subject, providing an Observer, which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a\u00a0Subject.</p>\n<p><strong>Every Subject is an Observer</strong>. It is an object with the methods <strong>next(v)</strong>, <strong>error(e)</strong>, and <strong>complete()</strong>. To feed a new value to the Subject, just call <strong>next(value),</strong> and it will be multicasted to the Observers registered to listen to the\u00a0Subject.</p>\n<p>Let\u2019s see the example below for a better understanding:</p>\n<pre>import { Subject } from 'rxjs';</pre>\n<pre>const subject = new Subject&lt;number&gt;();</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerA: ${v}`)<br>});<br>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerB: ${v}`)<br>});</pre>\n<pre>subject.next(1);<br>subject.next(2);</pre>\n<pre>// Logs:<br>// observerA: 1<br>// observerB: 1<br>// observerA: 2<br>// observerB: 2</pre>\n<p>Since a Subject is an Observer, this also means you may provide a Subject as the argument to the <strong>subscribe</strong> of any Observable.</p>\n<pre>import { Subject, from } from 'rxjs';</pre>\n<pre>const subject = new Subject&lt;number&gt;();</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerA: ${v}`)<br>});<br>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerB: ${v}`)<br>});</pre>\n<pre>const observable = from([1, 2, 3]);</pre>\n<pre>observable.subscribe(subject); // You can subscribe providing a Subject</pre>\n<pre>// Logs:<br>// observerA: 1<br>// observerB: 1<br>// observerA: 2<br>// observerB: 2<br>// observerA: 3<br>// observerB: 3</pre>\n<h3><strong>Few Specializations of the Subject\u00a0type</strong></h3>\n<ol>\n<li><strong>BehaviorSubject</strong></li>\n<li><strong>ReplaySubject</strong></li>\n<li><strong>AsyncSubject</strong></li>\n</ol>\n<h3><strong>BehaviorSubject</strong></h3>\n<p><strong><em>BehaviorSubject</em></strong><em>, which has a notion of \"</em><strong><em>the current value</em></strong><em>\". It stores the latest value emitted to its consumers, and whenever a new Observer subscribes, it will immediately receive the \"current value\" from the BehaviorSubject.</em></p>\n<p>In the below example, the <strong>BehaviorSubject</strong> is initialized with the value 0 which the first Observer receives when it subscribes. The second Observer receives the value 2 even though it subscribed after the value 2 was\u00a0sent.</p>\n<pre>import { BehaviorSubject } from 'rxjs';<br>const subject = new BehaviorSubject(0); // 0 is the initial value</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerA: ${v}`)<br>});</pre>\n<pre>subject.next(1);<br>subject.next(2);</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerB: ${v}`)<br>});</pre>\n<pre>subject.next(3);</pre>\n<pre>// Logs<br>// observerA: 0<br>// observerA: 1<br>// observerA: 2<br>// observerB: 2<br>// observerA: 3<br>// observerB: 3</pre>\n<h3><strong>ReplaySubject</strong></h3>\n<p><em>A </em><strong>ReplaySubject</strong><em> records multiple values from the Observable execution and replays them to new subscribers.</em></p>\n<p>When creating a <strong>ReplaySubject</strong>, you can specify how many values to\u00a0replay:</p>\n<pre>import { ReplaySubject } from 'rxjs';<br>const subject = new ReplaySubject(3); // buffer 3 values for new subscribers</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerA: ${v}`)<br>});</pre>\n<pre>subject.next(1);<br>subject.next(2);<br>subject.next(3);<br>subject.next(4);</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerB: ${v}`)<br>});</pre>\n<pre>subject.next(5);</pre>\n<pre>// Logs:<br>// observerA: 1<br>// observerA: 2<br>// observerA: 3<br>// observerA: 4<br>// observerB: 2<br>// observerB: 3<br>// observerB: 4<br>// observerA: 5<br>// observerB: 5</pre>\n<p>As you can see last 3 values are stored for the new subscriber which is 2, 3, and\u00a04.</p>\n<p><strong>Window time in ReplaySubject</strong></p>\n<p>ReplaySubject takes one more argument which specifies a <em>window time</em> in milliseconds.</p>\n<p>Besides the buffer size, to determine how old the recorded values can be we can specify <em>window\u00a0time.</em></p>\n<p>Let\u2019s see the example below, we use a large buffer size of <strong>100</strong>, but a window time parameter of just <strong>500</strong> milliseconds.</p>\n<pre>import { ReplaySubject } from 'rxjs';<br>const subject = new ReplaySubject(100, 500 /* windowTime */);</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerA: ${v}`)<br>});</pre>\n<pre>let i = 1;<br>setInterval(() =&gt; subject.next(i++), 200);</pre>\n<pre>setTimeout(() =&gt; {<br>  subject.subscribe({<br>    next: (v) =&gt; console.log(`observerB: ${v}`)<br>  });<br>}, 1000);</pre>\n<pre>// Logs<br>// observerA: 1<br>// observerA: 2<br>// observerA: 3<br>// observerA: 4<br>// observerA: 5<br>// observerB: 3<br>// observerB: 4<br>// observerB: 5<br>// observerA: 6<br>// observerB: 6<br>// ...</pre>\n<p>With the 500 milliseconds(0.5 second) windowTime the replay subject is only able to store the last 3 values under this time regardless of the buffer\u00a0size.</p>\n<h3><strong>AsyncSubject</strong></h3>\n<p><em>The </em><strong>AsyncSubject</strong><em> is a variant where only the last value of the Observable execution is sent to its observers, and only when the execution completes.</em></p>\n<pre>import { AsyncSubject } from 'rxjs';<br>const subject = new AsyncSubject();</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerA: ${v}`)<br>});</pre>\n<pre>subject.next(1);<br>subject.next(2);<br>subject.next(3);<br>subject.next(4);</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerB: ${v}`)<br>});</pre>\n<pre>subject.next(5);<br>subject.complete();</pre>\n<pre>// Logs:<br>// observerA: 5<br>// observerB: 5</pre>\n<p>In the above example, the last value observers will get only after calling <strong>subject.complete()</strong> without calling <strong>complete()</strong> method no value will be sent to observers.</p>\n<p>Thank you, for reading this blog, hope you liked it please give applause and\u00a0follow.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f749e09b73ae\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<blockquote>A Subject is like an Observable, but can multicast to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*6KEtzMVVR5a7KqOL\"></figure><p><strong>Every Subject is an Observable</strong>. You can subscribe to a Subject, providing an Observer, which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a\u00a0Subject.</p>\n<p><strong>Every Subject is an Observer</strong>. It is an object with the methods <strong>next(v)</strong>, <strong>error(e)</strong>, and <strong>complete()</strong>. To feed a new value to the Subject, just call <strong>next(value),</strong> and it will be multicasted to the Observers registered to listen to the\u00a0Subject.</p>\n<p>Let\u2019s see the example below for a better understanding:</p>\n<pre>import { Subject } from 'rxjs';</pre>\n<pre>const subject = new Subject&lt;number&gt;();</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerA: ${v}`)<br>});<br>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerB: ${v}`)<br>});</pre>\n<pre>subject.next(1);<br>subject.next(2);</pre>\n<pre>// Logs:<br>// observerA: 1<br>// observerB: 1<br>// observerA: 2<br>// observerB: 2</pre>\n<p>Since a Subject is an Observer, this also means you may provide a Subject as the argument to the <strong>subscribe</strong> of any Observable.</p>\n<pre>import { Subject, from } from 'rxjs';</pre>\n<pre>const subject = new Subject&lt;number&gt;();</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerA: ${v}`)<br>});<br>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerB: ${v}`)<br>});</pre>\n<pre>const observable = from([1, 2, 3]);</pre>\n<pre>observable.subscribe(subject); // You can subscribe providing a Subject</pre>\n<pre>// Logs:<br>// observerA: 1<br>// observerB: 1<br>// observerA: 2<br>// observerB: 2<br>// observerA: 3<br>// observerB: 3</pre>\n<h3><strong>Few Specializations of the Subject\u00a0type</strong></h3>\n<ol>\n<li><strong>BehaviorSubject</strong></li>\n<li><strong>ReplaySubject</strong></li>\n<li><strong>AsyncSubject</strong></li>\n</ol>\n<h3><strong>BehaviorSubject</strong></h3>\n<p><strong><em>BehaviorSubject</em></strong><em>, which has a notion of \"</em><strong><em>the current value</em></strong><em>\". It stores the latest value emitted to its consumers, and whenever a new Observer subscribes, it will immediately receive the \"current value\" from the BehaviorSubject.</em></p>\n<p>In the below example, the <strong>BehaviorSubject</strong> is initialized with the value 0 which the first Observer receives when it subscribes. The second Observer receives the value 2 even though it subscribed after the value 2 was\u00a0sent.</p>\n<pre>import { BehaviorSubject } from 'rxjs';<br>const subject = new BehaviorSubject(0); // 0 is the initial value</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerA: ${v}`)<br>});</pre>\n<pre>subject.next(1);<br>subject.next(2);</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerB: ${v}`)<br>});</pre>\n<pre>subject.next(3);</pre>\n<pre>// Logs<br>// observerA: 0<br>// observerA: 1<br>// observerA: 2<br>// observerB: 2<br>// observerA: 3<br>// observerB: 3</pre>\n<h3><strong>ReplaySubject</strong></h3>\n<p><em>A </em><strong>ReplaySubject</strong><em> records multiple values from the Observable execution and replays them to new subscribers.</em></p>\n<p>When creating a <strong>ReplaySubject</strong>, you can specify how many values to\u00a0replay:</p>\n<pre>import { ReplaySubject } from 'rxjs';<br>const subject = new ReplaySubject(3); // buffer 3 values for new subscribers</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerA: ${v}`)<br>});</pre>\n<pre>subject.next(1);<br>subject.next(2);<br>subject.next(3);<br>subject.next(4);</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerB: ${v}`)<br>});</pre>\n<pre>subject.next(5);</pre>\n<pre>// Logs:<br>// observerA: 1<br>// observerA: 2<br>// observerA: 3<br>// observerA: 4<br>// observerB: 2<br>// observerB: 3<br>// observerB: 4<br>// observerA: 5<br>// observerB: 5</pre>\n<p>As you can see last 3 values are stored for the new subscriber which is 2, 3, and\u00a04.</p>\n<p><strong>Window time in ReplaySubject</strong></p>\n<p>ReplaySubject takes one more argument which specifies a <em>window time</em> in milliseconds.</p>\n<p>Besides the buffer size, to determine how old the recorded values can be we can specify <em>window\u00a0time.</em></p>\n<p>Let\u2019s see the example below, we use a large buffer size of <strong>100</strong>, but a window time parameter of just <strong>500</strong> milliseconds.</p>\n<pre>import { ReplaySubject } from 'rxjs';<br>const subject = new ReplaySubject(100, 500 /* windowTime */);</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerA: ${v}`)<br>});</pre>\n<pre>let i = 1;<br>setInterval(() =&gt; subject.next(i++), 200);</pre>\n<pre>setTimeout(() =&gt; {<br>  subject.subscribe({<br>    next: (v) =&gt; console.log(`observerB: ${v}`)<br>  });<br>}, 1000);</pre>\n<pre>// Logs<br>// observerA: 1<br>// observerA: 2<br>// observerA: 3<br>// observerA: 4<br>// observerA: 5<br>// observerB: 3<br>// observerB: 4<br>// observerB: 5<br>// observerA: 6<br>// observerB: 6<br>// ...</pre>\n<p>With the 500 milliseconds(0.5 second) windowTime the replay subject is only able to store the last 3 values under this time regardless of the buffer\u00a0size.</p>\n<h3><strong>AsyncSubject</strong></h3>\n<p><em>The </em><strong>AsyncSubject</strong><em> is a variant where only the last value of the Observable execution is sent to its observers, and only when the execution completes.</em></p>\n<pre>import { AsyncSubject } from 'rxjs';<br>const subject = new AsyncSubject();</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerA: ${v}`)<br>});</pre>\n<pre>subject.next(1);<br>subject.next(2);<br>subject.next(3);<br>subject.next(4);</pre>\n<pre>subject.subscribe({<br>  next: (v) =&gt; console.log(`observerB: ${v}`)<br>});</pre>\n<pre>subject.next(5);<br>subject.complete();</pre>\n<pre>// Logs:<br>// observerA: 5<br>// observerB: 5</pre>\n<p>In the above example, the last value observers will get only after calling <strong>subject.complete()</strong> without calling <strong>complete()</strong> method no value will be sent to observers.</p>\n<p>Thank you, for reading this blog, hope you liked it please give applause and\u00a0follow.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f749e09b73ae\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["information-technology","rxjs","javascript","angular","software-development"]},{"title":"First Step towards Git and Github","pubDate":"2021-09-10 13:05:52","link":"https://medium.com/@sanjayofficial94/first-step-towards-git-and-github-bcb5107362e9?source=rss-dfd30b357e8c------2","guid":"https://medium.com/p/bcb5107362e9","author":"Sanjay Mehta","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*LQJVzoo_10CD4xYV8T5zJw.jpeg\"></figure><h3>Introduction</h3>\n<p>In the simple term\u00a0, <strong>Git</strong><em> is software you install on your computer to interact with Git repositories and </em><strong>GitHub</strong><em> is a very popular website (and free to use), which is used to host GitHub repositories.</em></p>\n<p><strong>Git</strong><em> </em>is a free and open-source <strong>distributed version control system</strong> designed to handle everything from small to very large projects with speed and efficiency.</p>\n<p>Let\u2019s understand what is <strong>Version Control\u00a0System</strong>.</p>\n<p><strong>Version control</strong> <em>is a system that records changes to a file or set of files over time so that you can recall specific versions\u00a0later</em>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*MM665bvy9fdsQ79T.jpg\"></figure><p><strong>Daily life example:</strong> <em>Imagine that your boss gave you a task to write an article on the paper in one hour. You are sure that you will finish perfectly but as we\u00a0,are human there are always possibilities, to make mistakes. After one hour, you just realized that made a mistake. Oh, no! Was there a way to fix\u00a0it?</em></p>\n<p><em>In real life, you can take precautions on time to avoid unwanted situations or if something has really happened before prevention, simply means that it happened. So, we cannot change things occurred in past in actual life. Fortunately, version control systems help us to go back in time without a magic wand. Besides, it has more benefits than undo steps. Let\u2019s learn\u00a0more.</em></p>\n<p>Before understanding <strong>distributed version control system\u00a0, </strong>let\u2019s take a look at types of Version Control\u00a0System.</p>\n<p>There are many version control systems out there. Often they are divided into two groups: \u201c<strong>centralized</strong>\u201d and \u201c<strong>distributed</strong>\u201d.</p>\n<ul>\n<li>Centralized Version Control\u00a0System</li>\n<li>Distributed Version Control\u00a0System</li>\n</ul>\n<p><strong>Centralized Version Control System(CVCS)</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*CJkg4s2yYac2mcLK.png\"></figure><p>Centralized version control systems are based on the idea that there is a single \u201ccentral\u201d copy of your project somewhere (probably on a server), and programmers will \u201ccommit\u201d their changes to this central\u00a0copy.</p>\n<p>\u201cCommitting\u201d a change simply means recording the change in the central system. Other programmers can then see this change. They can also pull down the change, and the version control tool will automatically update the contents of any files that were\u00a0changed.</p>\n<p><strong>Drawbacks of\u00a0CVCS</strong></p>\n<ul>\n<li>It is not locally available, which means we must connect to the network to perform operations.</li>\n<li>During the operations, if the central server gets crashed, there is a high chance of losing the\u00a0data.</li>\n<li>For every command, CVCS connects the central server which impacts speed of operation</li>\n</ul>\n<p>\u200bThe <strong>Distributed Version Control System</strong> is developed to overcome all these\u00a0issues.</p>\n<p><strong>Distributed Version Control System(DVCS)</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*txQmIHx93c0ykxtw.png\"></figure><p>In distributed version control most of the mechanism or model applies the same as centralized. The only major difference you will find here is, instead of one single repository which is the server, here every single developer or client has their own server and they will have a copy of the entire history or version of the code and all of its branches in their local server or machine. Basically, every client or user can work locally and disconnected which is more convenient than centralized source control and that\u2019s why it is called distributed.</p>\n<p>It doesn\u2019t follow the way of communicating or merging the code straight forward to the master repository after making changes. Firstly you commit all the changes in your own server or repository and then the \u2018set of changes\u2019 will merge to the master repository.</p>\n<h3>Some Basic Commands to use\u00a0GIT</h3>\n<h4>Getting a Git Repository</h4>\n<p>There are two ways to obtain a Git repository\u00a0:</p>\n<ol>\n<li>You can take a local directory that is currently not under version control, and turn it into a Git repository, or</li>\n<li>You can <strong>clone</strong> an existing Git repository from elsewhere.</li>\n</ol>\n<p>In either case, you end up with a Git repository on your local machine, ready for\u00a0work.</p>\n<h4><strong>Initializing a Repository in an Existing Directory</strong></h4>\n<p>To create a new repo, you\u2019ll use the git init command. git init is a one-time command you use during the initial setup of a new repo. Executing this command will create a new\u00a0.git subdirectory in your current working directory. This will also create a new main\u00a0branch.</p>\n<pre>$ git init</pre>\n<h4>Cloning an Existing Repository</h4>\n<p>If a project has already been set up in a central repository, the clone command is the most common way for users to obtain a local development clone. Like git init, cloning is generally a one-time operation. Once a developer has obtained a working copy, all version control operations are managed through their local repository.</p>\n<pre>$ git clone &lt;repo url&gt;</pre>\n<h4>Recording Changes to the Repository</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/0*32uEJMCYsgpVYxph.png\"></figure><p>Remember that each file in your working directory can be in one of two states: <strong>tracked</strong> or <strong>untracked</strong>. Tracked files are files that were in the last snapshot, as well as any newly staged files; they can be unmodified, modified, or staged. In short, tracked files are files that Git knows\u00a0about.</p>\n<p>Untracked files are everything else\u200a\u2014\u200aany files in your working directory that were not in your last snapshot and are not in your staging area. When you first clone a repository, all of your files will be tracked and unmodified because Git just checked them out and you haven\u2019t edited anything.</p>\n<p>As you edit files, Git sees them as modified, because you\u2019ve changed them since your last commit. As you work, you selectively stage these modified files and then commit all those staged changes, and the cycle\u00a0repeats.</p>\n<h4>Checking the Status of Your\u00a0Files</h4>\n<p>The git status command displays the state of the working directory and the staging area. It lets you see which changes have been staged, which haven\u2019t, and which files aren\u2019t being tracked by\u00a0Git.</p>\n<pre>$ git status<br>On branch master<br>Your branch is up-to-date with 'origin/master'.<br>nothing to commit, working tree clean</pre>\n<p>This means you have a clean working directory; in other words, none of your tracked files are modified. Git also doesn\u2019t see any untracked files, or they would be listed here. Finally, the command tells you which branch you\u2019re\u00a0on.</p>\n<h4>Saving changes</h4>\n<ul>\n<li>git add</li>\n<li>git commit</li>\n<li>git diff</li>\n<li>git stash</li>\n</ul>\n<h4>git add</h4>\n<p>The git add command adds a change in the working directory to the staging area. It tells Git that you want to include updates to a particular file in the next commit. However, git add doesn't really affect the repository in any significant way\u2014changes are not actually recorded until you run git\u00a0commit.</p>\n<pre>$ git add &lt;file&gt; <br>// Stage all changes in &lt;file&gt; for the next commit.</pre>\n<pre>$ git add &lt;directory&gt;<br>// Stage all changes in &lt;directory&gt; for the next commit.</pre>\n<h4>git commit</h4>\n<p>The git commit command captures a snapshot of the project's currently staged changes. Committed snapshots can be thought of as \u201csafe\u201d versions of a project\u2014Git will never change them unless you explicitly ask it to. Prior to the execution of git commit, The git add command is used to promote or 'stage' changes to the project that will be stored in a\u00a0commit.</p>\n<pre>$ git commit -m \"commit message\"</pre>\n<h4>git diff</h4>\n<p>git status command is too vague for you\u200a\u2014\u200ayou want to know exactly what you changed, not just which files were changed\u200a\u2014\u200ayou can use the git diff command. You\u2019ll probably use it most often to answer these two questions: What have you changed but not yet staged? And what have you staged that you are about to commit? Although git status answers those questions very generally by listing the file names, git diff shows you the exact lines added and removed\u200a\u2014\u200athe patch, as it\u00a0were.</p>\n<p>To see what you\u2019ve changed but not yet staged, type git diff with no other arguments:</p>\n<pre>$ git diff</pre>\n<p>That command compares what is in your working directory with what is in your staging area. The result tells you the changes you\u2019ve made that you haven\u2019t yet\u00a0staged.</p>\n<p>You can use git diff --staged. This command compares your staged changes to your last\u00a0commit:</p>\n<pre>$ git diff --staged</pre>\n<h4>git stash</h4>\n<p>Often, when you\u2019ve been working on part of your project, things are in a messy state and you want to switch branches for a bit to work on something else. The problem is, you don\u2019t want to do a commit of half-done work just so you can get back to this point later. The answer to this issue is the git stash\u00a0command.</p>\n<p>Stashing takes the dirty state of your working directory\u200a\u2014\u200athat is, your modified tracked files and staged changes\u200a\u2014\u200aand saves it on a stack of unfinished changes that you can reapply at any time (even on a different branch).</p>\n<pre>$ git stash<br>Saved working directory and index state \\<br>  \"WIP on master: 049d078 Create index file\"<br>HEAD is now at 049d078 Create index file<br>(To restore them type \"git stash apply\")</pre>\n<p>You can reapply the one you just stashed by using the command\u00a0: git stash\u00a0apply</p>\n<pre>$ git stash apply<br>On branch master<br>Changes not staged for commit:<br>  (use \"git add &lt;file&gt;...\" to update what will be committed)<br>  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)<br><br>\tmodified:   index.html<br>\tmodified:   lib/simplegit.rb<br><br>no changes added to commit (use \"git add\" and/or \"git commit -a\")</pre>\n<p>Thank you, for reading this post\u00a0, hope you liked it please give an applause.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bcb5107362e9\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*LQJVzoo_10CD4xYV8T5zJw.jpeg\"></figure><h3>Introduction</h3>\n<p>In the simple term\u00a0, <strong>Git</strong><em> is software you install on your computer to interact with Git repositories and </em><strong>GitHub</strong><em> is a very popular website (and free to use), which is used to host GitHub repositories.</em></p>\n<p><strong>Git</strong><em> </em>is a free and open-source <strong>distributed version control system</strong> designed to handle everything from small to very large projects with speed and efficiency.</p>\n<p>Let\u2019s understand what is <strong>Version Control\u00a0System</strong>.</p>\n<p><strong>Version control</strong> <em>is a system that records changes to a file or set of files over time so that you can recall specific versions\u00a0later</em>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*MM665bvy9fdsQ79T.jpg\"></figure><p><strong>Daily life example:</strong> <em>Imagine that your boss gave you a task to write an article on the paper in one hour. You are sure that you will finish perfectly but as we\u00a0,are human there are always possibilities, to make mistakes. After one hour, you just realized that made a mistake. Oh, no! Was there a way to fix\u00a0it?</em></p>\n<p><em>In real life, you can take precautions on time to avoid unwanted situations or if something has really happened before prevention, simply means that it happened. So, we cannot change things occurred in past in actual life. Fortunately, version control systems help us to go back in time without a magic wand. Besides, it has more benefits than undo steps. Let\u2019s learn\u00a0more.</em></p>\n<p>Before understanding <strong>distributed version control system\u00a0, </strong>let\u2019s take a look at types of Version Control\u00a0System.</p>\n<p>There are many version control systems out there. Often they are divided into two groups: \u201c<strong>centralized</strong>\u201d and \u201c<strong>distributed</strong>\u201d.</p>\n<ul>\n<li>Centralized Version Control\u00a0System</li>\n<li>Distributed Version Control\u00a0System</li>\n</ul>\n<p><strong>Centralized Version Control System(CVCS)</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*CJkg4s2yYac2mcLK.png\"></figure><p>Centralized version control systems are based on the idea that there is a single \u201ccentral\u201d copy of your project somewhere (probably on a server), and programmers will \u201ccommit\u201d their changes to this central\u00a0copy.</p>\n<p>\u201cCommitting\u201d a change simply means recording the change in the central system. Other programmers can then see this change. They can also pull down the change, and the version control tool will automatically update the contents of any files that were\u00a0changed.</p>\n<p><strong>Drawbacks of\u00a0CVCS</strong></p>\n<ul>\n<li>It is not locally available, which means we must connect to the network to perform operations.</li>\n<li>During the operations, if the central server gets crashed, there is a high chance of losing the\u00a0data.</li>\n<li>For every command, CVCS connects the central server which impacts speed of operation</li>\n</ul>\n<p>\u200bThe <strong>Distributed Version Control System</strong> is developed to overcome all these\u00a0issues.</p>\n<p><strong>Distributed Version Control System(DVCS)</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*txQmIHx93c0ykxtw.png\"></figure><p>In distributed version control most of the mechanism or model applies the same as centralized. The only major difference you will find here is, instead of one single repository which is the server, here every single developer or client has their own server and they will have a copy of the entire history or version of the code and all of its branches in their local server or machine. Basically, every client or user can work locally and disconnected which is more convenient than centralized source control and that\u2019s why it is called distributed.</p>\n<p>It doesn\u2019t follow the way of communicating or merging the code straight forward to the master repository after making changes. Firstly you commit all the changes in your own server or repository and then the \u2018set of changes\u2019 will merge to the master repository.</p>\n<h3>Some Basic Commands to use\u00a0GIT</h3>\n<h4>Getting a Git Repository</h4>\n<p>There are two ways to obtain a Git repository\u00a0:</p>\n<ol>\n<li>You can take a local directory that is currently not under version control, and turn it into a Git repository, or</li>\n<li>You can <strong>clone</strong> an existing Git repository from elsewhere.</li>\n</ol>\n<p>In either case, you end up with a Git repository on your local machine, ready for\u00a0work.</p>\n<h4><strong>Initializing a Repository in an Existing Directory</strong></h4>\n<p>To create a new repo, you\u2019ll use the git init command. git init is a one-time command you use during the initial setup of a new repo. Executing this command will create a new\u00a0.git subdirectory in your current working directory. This will also create a new main\u00a0branch.</p>\n<pre>$ git init</pre>\n<h4>Cloning an Existing Repository</h4>\n<p>If a project has already been set up in a central repository, the clone command is the most common way for users to obtain a local development clone. Like git init, cloning is generally a one-time operation. Once a developer has obtained a working copy, all version control operations are managed through their local repository.</p>\n<pre>$ git clone &lt;repo url&gt;</pre>\n<h4>Recording Changes to the Repository</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/0*32uEJMCYsgpVYxph.png\"></figure><p>Remember that each file in your working directory can be in one of two states: <strong>tracked</strong> or <strong>untracked</strong>. Tracked files are files that were in the last snapshot, as well as any newly staged files; they can be unmodified, modified, or staged. In short, tracked files are files that Git knows\u00a0about.</p>\n<p>Untracked files are everything else\u200a\u2014\u200aany files in your working directory that were not in your last snapshot and are not in your staging area. When you first clone a repository, all of your files will be tracked and unmodified because Git just checked them out and you haven\u2019t edited anything.</p>\n<p>As you edit files, Git sees them as modified, because you\u2019ve changed them since your last commit. As you work, you selectively stage these modified files and then commit all those staged changes, and the cycle\u00a0repeats.</p>\n<h4>Checking the Status of Your\u00a0Files</h4>\n<p>The git status command displays the state of the working directory and the staging area. It lets you see which changes have been staged, which haven\u2019t, and which files aren\u2019t being tracked by\u00a0Git.</p>\n<pre>$ git status<br>On branch master<br>Your branch is up-to-date with 'origin/master'.<br>nothing to commit, working tree clean</pre>\n<p>This means you have a clean working directory; in other words, none of your tracked files are modified. Git also doesn\u2019t see any untracked files, or they would be listed here. Finally, the command tells you which branch you\u2019re\u00a0on.</p>\n<h4>Saving changes</h4>\n<ul>\n<li>git add</li>\n<li>git commit</li>\n<li>git diff</li>\n<li>git stash</li>\n</ul>\n<h4>git add</h4>\n<p>The git add command adds a change in the working directory to the staging area. It tells Git that you want to include updates to a particular file in the next commit. However, git add doesn't really affect the repository in any significant way\u2014changes are not actually recorded until you run git\u00a0commit.</p>\n<pre>$ git add &lt;file&gt; <br>// Stage all changes in &lt;file&gt; for the next commit.</pre>\n<pre>$ git add &lt;directory&gt;<br>// Stage all changes in &lt;directory&gt; for the next commit.</pre>\n<h4>git commit</h4>\n<p>The git commit command captures a snapshot of the project's currently staged changes. Committed snapshots can be thought of as \u201csafe\u201d versions of a project\u2014Git will never change them unless you explicitly ask it to. Prior to the execution of git commit, The git add command is used to promote or 'stage' changes to the project that will be stored in a\u00a0commit.</p>\n<pre>$ git commit -m \"commit message\"</pre>\n<h4>git diff</h4>\n<p>git status command is too vague for you\u200a\u2014\u200ayou want to know exactly what you changed, not just which files were changed\u200a\u2014\u200ayou can use the git diff command. You\u2019ll probably use it most often to answer these two questions: What have you changed but not yet staged? And what have you staged that you are about to commit? Although git status answers those questions very generally by listing the file names, git diff shows you the exact lines added and removed\u200a\u2014\u200athe patch, as it\u00a0were.</p>\n<p>To see what you\u2019ve changed but not yet staged, type git diff with no other arguments:</p>\n<pre>$ git diff</pre>\n<p>That command compares what is in your working directory with what is in your staging area. The result tells you the changes you\u2019ve made that you haven\u2019t yet\u00a0staged.</p>\n<p>You can use git diff --staged. This command compares your staged changes to your last\u00a0commit:</p>\n<pre>$ git diff --staged</pre>\n<h4>git stash</h4>\n<p>Often, when you\u2019ve been working on part of your project, things are in a messy state and you want to switch branches for a bit to work on something else. The problem is, you don\u2019t want to do a commit of half-done work just so you can get back to this point later. The answer to this issue is the git stash\u00a0command.</p>\n<p>Stashing takes the dirty state of your working directory\u200a\u2014\u200athat is, your modified tracked files and staged changes\u200a\u2014\u200aand saves it on a stack of unfinished changes that you can reapply at any time (even on a different branch).</p>\n<pre>$ git stash<br>Saved working directory and index state \\<br>  \"WIP on master: 049d078 Create index file\"<br>HEAD is now at 049d078 Create index file<br>(To restore them type \"git stash apply\")</pre>\n<p>You can reapply the one you just stashed by using the command\u00a0: git stash\u00a0apply</p>\n<pre>$ git stash apply<br>On branch master<br>Changes not staged for commit:<br>  (use \"git add &lt;file&gt;...\" to update what will be committed)<br>  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)<br><br>\tmodified:   index.html<br>\tmodified:   lib/simplegit.rb<br><br>no changes added to commit (use \"git add\" and/or \"git commit -a\")</pre>\n<p>Thank you, for reading this post\u00a0, hope you liked it please give an applause.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bcb5107362e9\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["technology","software-development","devops","git"]},{"title":"S.O.L.I.D. Principals","pubDate":"2021-09-02 15:24:47","link":"https://medium.com/@sanjayofficial94/s-o-l-i-d-principals-41a5b3b604eb?source=rss-dfd30b357e8c------2","guid":"https://medium.com/p/41a5b3b604eb","author":"Sanjay Mehta","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*AOzeP3iVWba5jd5SSj963w.png\"></figure><h3><strong>Introduction</strong></h3>\n<p><strong><em>SOLID</em></strong> is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also known as <a href=\"http://en.wikipedia.org/wiki/Robert_Cecil_Martin\">Uncle\u00a0Bob</a>).</p>\n<p><strong>SOLID</strong> stands\u00a0for:</p>\n<ul>\n<li>\n<strong>S</strong>\u200a\u2014\u200aSingle Responsibility Principle</li>\n<li>\n<strong>O</strong>\u200a\u2014\u200aOpen-closed Principle</li>\n<li>\n<strong>L</strong>\u200a\u2014\u200aLiskov Substitution Principle</li>\n<li>\n<strong>I</strong>\u200a\u2014\u200aInterface Segregation Principle</li>\n<li>\n<strong>D</strong>\u200a\u2014\u200aDependency Inversion Principle</li>\n</ul>\n<h3>Why use the Solid Principles of\u00a0OOP?</h3>\n<ul>\n<li>Object Oriented Programming is a powerful\u00a0concept.</li>\n<li>But, OOP doesn\u2019t always lead to quality software.</li>\n<li>The five principles focus on dependency management.</li>\n<li>Poor Dependency Management leads to code that is brittle, fragile, and hard to\u00a0change.</li>\n<li>Proper dependency management leads to quality code that is easy to maintain.</li>\n</ul>\n<h3>Single Responsibility Principle</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/639/1*4iG1xoSStluQV73wyCQhEw.png\"></figure><p><strong>Single Responsibility Principle states\u00a0that</strong></p>\n<p><em>A class should have one and only one reason to change, meaning that a class should have only one\u00a0job.</em></p>\n<ul>\n<li>Every class should have a single responsibility.</li>\n<li>Classes should be small. No more than a screen full of\u00a0code.</li>\n<li>Avoid <strong>GOD</strong>\u00a0classes</li>\n<li>Split big classes into smaller\u00a0classes.</li>\n</ul>\n<p>Let\u2019s understand with the help of\u00a0code.</p>\n<pre>public class SimpleCalculator{</pre>\n<pre>  public int add(int a , int b){<br>      return a + b;<br>  }</pre>\n<pre>  public int subtract(int a , int b){<br>      return a - b;<br>  }</pre>\n<pre>  public int multiply(int a , int b){<br>      return a * b;<br>  }</pre>\n<pre>  public int divide(int a , int b){<br>      return a/b;<br>  }<br><br>  public void printSum(int sum){<br>      System.out.println(s);<br>  }</pre>\n<pre>}</pre>\n<p>The Simple calculator class violates the rule of SRP. As per the rule a class should have one job to do but the Simple calculator class have two responsibilities <strong>calculating</strong> and <strong>printing</strong> the\u00a0value.</p>\n<p>We should create another class ValuePrinter that handles only printing the\u00a0value.</p>\n<pre>public class ValuePrinter{</pre>\n<pre>public void printSum(int value){<br>      System.out.println(value);<br>  }</pre>\n<pre>}</pre>\n<pre>public class SimpleCalculator{</pre>\n<pre>public int add(int a , int b){<br>      return a + b;<br>  }</pre>\n<pre>public int subtract(int a , int b){<br>      return a - b;<br>  }</pre>\n<pre>public int multiply(int a , int b){<br>      return a * b;<br>  }</pre>\n<pre>public int divide(int a , int b){<br>      return a/b;<br>  }<br>}</pre>\n<p>That satisfies the single-responsibility principle.</p>\n<h3>Open-Closed Principal</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/880/1*sZt3CvVVYLfsuIXIX1yOBA.png\"></figure><p><strong>Open-Closed principle states\u00a0that</strong></p>\n<p><em>Objects or entities should be open for extension but closed for modification.</em></p>\n<ul>\n<li>Classes should be open for extension.</li>\n<li>But close for modification.</li>\n<li>You should be able to extend a classes behavior, without modifying it.</li>\n<li>Use private variables with getters and setters -ONLY when you need\u00a0them.</li>\n<li>Use abstract base\u00a0classes.</li>\n</ul>\n<p>Consider an insurance system that validates health insurance claims before approving one. A <strong>HealthInsuranceSurveyor</strong> class responsible to validate claims and a <strong>ClaimApprovalManager</strong> class responsible to approve\u00a0claims.</p>\n<pre>public class HealthInsuranceSurveyor{</pre>\n<pre>public boolean isValidClaim(){<br>    System.out.println(\"HealthInsuranceSurveyor: Validating health insurance claim...\");<br><br>   return true;</pre>\n<pre> }</pre>\n<pre>public class ClaimApprovalManager{</pre>\n<pre>public void processHeathClaim(HealthInsuranceSurveyor surveyor){<br>       if(surveyor.isValidClaim()){<br>           System.out.println(\"ClaimApprovalManager : Valid claim. <br>Currently processing claim for approval....\");</pre>\n<pre>      }</pre>\n<pre>  }</pre>\n<pre>}</pre>\n<p>Both the <strong>HealthInsuranceSurveyor</strong> and <strong>ClaimApprovalManager</strong> classes work fine and the design for the insurance system appears perfect until a new requirement to process vehicle insurance claims arises.We now need to include a new <strong>VehicleInsuranceSurveyor</strong> class, and this should not create any problems. But, what we also need is to modify the <strong>ClaimApprovalManager</strong> class to process vehicle insurance claims. This is how the modified <strong>ClaimApprovalManager</strong> will\u00a0be:</p>\n<h4>Modified ClaimApprovalManager.java</h4>\n<pre>public class ClaimApprovalManager{</pre>\n<pre>public void processHeathClaim(HealthInsuranceSurveyor surveyor){<br>       if(surveyor.isValidClaim()){<br>           System.out.println(\"ClaimApprovalManager : Valid claim. <br>Currently processing claim for approval....\");</pre>\n<pre>}<br>}<br>public void processVehicleClaim(VehicleInsuranceSurveyor surveyor){<br>     if(surveyor.isValidClaim()){<br>           System.out.println(\"ClaimApprovalManager : Valid claim. <br>Currently processing claim for approval....\");<br>}<br>}<br>}</pre>\n<p>In the example above, we modified the <strong>ClaimApprovalManager</strong> class by adding a new <strong>processVehicleClaim</strong>( ) method to incorporate a new functionality (claim approval of vehicle insurance).This is a clear violation of the Open Closed Principle.</p>\n<p>The ideal approach for the insurance claim example would have been to design the ClaimApprovalManager class in a way that it\u00a0remains:</p>\n<ul>\n<li>\n<strong>Open</strong> to support more types of insurance claims.</li>\n<li>\n<strong>Closed</strong> for any modifications whenever support for a new type of claim is\u00a0added.</li>\n</ul>\n<p>To achieve this, let\u2019s introduce a layer of abstraction by creating an abstract class to represent different claim validation behaviors. We will name the class InsuranceSurveyor.</p>\n<h4>InsuranceSurveyor.java</h4>\n<pre>public abstract class InsuranceSurveyor{<br>  public abstract boolean isValidClaim();<br>}</pre>\n<h4>HealthInsuranceSurveyor.java</h4>\n<pre>public class HealthInsuranceSurveyor extends InsuranceSurveyor{</pre>\n<pre>public boolean isValidClaim(){<br>    System.out.println(\"HealthInsuranceSurveyor: Validating health insurance claim...\");<br><br>   return true;</pre>\n<pre>}</pre>\n<h4>VehicleInsuranceSurveyor.java</h4>\n<pre>public class VehicleInsuranceSurveyor extends InsuranceSurveyor{</pre>\n<pre>public boolean isValidClaim(){<br>    System.out.println(\"VehicleInsuranceSurveyor: Validating vehicle insurance claim...\");<br><br>   return true;</pre>\n<pre>}</pre>\n<h4>ClaimApprovalManager.java</h4>\n<pre>public class ClaimApprovalManager{</pre>\n<pre>public void processHeathClaim(InsuranceSurveyor surveyor){<br>       if(surveyor.isValidClaim()){<br>           System.out.println(\"ClaimApprovalManager : Valid claim. <br>Currently processing claim for approval....\");<br>}<br>}<br>}</pre>\n<p>In the example above, we wrote a processClaim( ) method to accept a InsuranceSurveyor type instead of specifying a concrete type. In this way, any further addition of InsuranceSurveyor implementations will not affect the ClaimApprovalManager class. Our insurance system is now <strong>open</strong> to support more types of insurance claims, and <strong>closed</strong> for any modifications whenever a new claim type is\u00a0added.</p>\n<h3>Liskov Substitution Principle</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/656/1*q5JKXx_aLaulkqTxM77guw.png\"></figure><p><em>The principal defines that objects of a superclass shall be replaceable with object of its subclasses without breaking the application.</em></p>\n<ul>\n<li>That requires the objects of your subclasses to behave in the same way as the objects of your superclass.</li>\n<li>It means that we must make sure that new derived classes are extending the base classes without changing their behavior.</li>\n<li>It is an extension of Open Closed Principal.</li>\n<li>This principal helps you to implement OCP correctly.</li>\n</ul>\n<p>Let\u2019s take an example to understand it\u00a0better</p>\n<ol>\n<li>Calculate Area of Rectangle.</li>\n<li>Calculate Area of Square as\u00a0well</li>\n</ol>\n<p>As we know, <strong>Square is a Rectangle</strong> and if we talk about inheritance it is also be read as \u201c<strong>IS A</strong>\u201d relationship.</p>\n<p>So, we can create Rectangle as a base or super class and Square as sub\u00a0class.</p>\n<p><strong>Rectangle.java</strong></p>\n<pre>public class Rectangle {</pre>\n<pre> protected int width;<br> protected int height;</pre>\n<pre>public int getWidth(){<br>   return this.width;<br> }</pre>\n<pre>public int getHeight(){<br>   return this.height;<br> }<br><br>public void setHeight(int height){<br>  this.height = height;<br>}</pre>\n<pre>public void setWidth(int width){<br>  this.width = width;<br>}</pre>\n<pre>public int getArea(){<br> return this.height * this.width;<br>}<br>}</pre>\n<p><strong>Square.java</strong></p>\n<pre>public class Square extends Rectangle{ <br><br>public void setHeight(int height){<br>  this.height = height;<br>  this.width = height;</pre>\n<pre>}</pre>\n<pre>public void setWidth(int width){<br>  this.width = width;<br>  this.height = width;<br>}<br>}</pre>\n<p><strong>CalculateRectangleArea.java</strong></p>\n<pre>public class CalculateRectangleArea{</pre>\n<pre>public static void main(String[] args){<br><br>  Rectangle rect = new Rectangle();<br>  rect.setWidth(2);<br>  rect.setHeight(3);</pre>\n<pre>  System.out.println(\"Area of rectangle : \" + rect.getArea());</pre>\n<pre>}<br>}</pre>\n<pre>Output : <br>Area of rectangle : 6</pre>\n<p><strong>CalculateSquareArea.java</strong></p>\n<pre>public class CalculateSquareArea{</pre>\n<pre>public static void main(String[] args){<br><br>  Rectangle square = new Square();<br>  square.setWidth(2);<br>  square.setHeight(3);</pre>\n<pre>System.out.println(\"Area of square: \" + square.getArea());</pre>\n<pre>}<br>}</pre>\n<pre>Output : <br>Area of square : 9</pre>\n<p>Now, if we change the order of setWidth and setHeight method</p>\n<pre>public class CalculateSquareArea{</pre>\n<pre>public static void main(String[] args){<br><br>  Rectangle square = new Square();<br>  square.setHeight(3);<br>  square.setWidth(2);</pre>\n<pre>System.out.println(\"Area of square is : \" + square.getArea());</pre>\n<pre>}<br>}</pre>\n<pre>Output : <br>Area of square is : 4</pre>\n<p>The output after changing the order of method is not same\u00a0, so the above code violates the LSP principle i.e \u201c <em>The objects of your subclasses to behave in the same way as the objects of your superclass</em>\u201d.</p>\n<p><strong>How to identify violation of\u00a0LSP.</strong></p>\n<ul>\n<li>A not implemented method in the subclass.</li>\n<li>Subclass function overrides the base class method to give it new\u00a0meaning.</li>\n</ul>\n<p>Let\u2019s implement the LSP in the correct\u00a0manner.</p>\n<p><strong>Shape.java</strong></p>\n<pre>public abstract class Shape {<br> abstract public int getArea();<br>}</pre>\n<p><strong>Rectangle.java</strong></p>\n<pre>public class Rectangle extends Shape{</pre>\n<pre>protected int width;<br> protected int height;</pre>\n<pre>public int getWidth(){<br>   return this.width;<br> }</pre>\n<pre>public int getHeight(){<br>   return this.height;<br> }<br><br>public void setHeight(int height){<br>  this.height = height;<br>}</pre>\n<pre>public void setWidth(int width){<br>  this.width = width;<br>}</pre>\n<pre>@Override<br>public int getArea(){<br> return this.height * this.width;<br>}<br>}</pre>\n<p><strong>Square.java</strong></p>\n<pre>public class Square extends Shape{</pre>\n<pre>int length;</pre>\n<pre>public int getLength(){<br>   return this.length;<br> }<br><br>public void setLength(int length){<br>  this.length = length;<br>}</pre>\n<pre>@Override<br>public int getArea(){<br> return this.length * this.length;<br>}<br>}</pre>\n<p><strong>CalculateRectangleArea.java</strong></p>\n<pre>public class CalculateRectangleArea{</pre>\n<pre>public static void main(String[] args){<br><br>  Shape rect = new Rectangle();<br>  rect.setWidth(2);<br>  rect.setHeight(3);</pre>\n<pre>System.out.println(\"Area of rectangle : \" + rect.getArea());</pre>\n<pre>}<br>}</pre>\n<pre>Output : <br>Area of rectangle : 6</pre>\n<p><strong>CalculateSquareArea.java</strong></p>\n<pre>public class CalculateSquareArea{</pre>\n<pre>public static void main(String[] args){<br><br>  Shape square = new Square();<br>  square.setLength(2);</pre>\n<pre>System.out.println(\"Area of square : \" + square.getArea());</pre>\n<pre>}<br>}</pre>\n<pre>Output : <br>Area of square : 4</pre>\n<p><strong>Why we shouldn\u2019t violate\u00a0LSP.</strong></p>\n<ul>\n<li>The use of using abstract base class is that, in future, you can write a new subclass and insert it into existing, working, tested\u00a0code.</li>\n<li>The essence of the Open Closed Principal.</li>\n<li>However, when the subclasses don\u2019t adhere properly to the behavior of the base class, you have to go through the existing code and modify the subclasses accordingly.</li>\n<li>This is a blatant violation of the Open Closed Principal.</li>\n</ul>\n<h3>Interface Segregation Principle</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/1*5yfkFXUx_qJy7JsH3P-lzg.png\"></figure><p><em>This principle states that \u201cClients should not be forced to depend on methods that they do not use\u201d. Here, the term \u201cClients\u201d refers to the implementing classes of an interface.</em></p>\n<p>The <strong>Interface Segregation Principle</strong> advocates segregating a \u201cfat interface\u201d into smaller and <a href=\"https://en.wikipedia.org/wiki/Cohesion_%28computer_science%29\">highly cohesive</a> interfaces, known as \u201crole interfaces\u201d. Each \u201crole interface\u201d declares one or more methods for a specific behavior. Thus clients, instead of implementing a \u201cfat interface\u201d, can implement only those \u201crole interfaces\u201d whose methods are relevant to\u00a0them.</p>\n<h4>Interface Segregation Principle Violation (Bad Example):</h4>\n<p>Let\u2019s consider an example, the Athlete interface is an interface with some actions of an\u00a0athlete:</p>\n<pre>public interface Athlete {</pre>\n<pre>void compete();</pre>\n<pre>void swim();</pre>\n<pre>void highJump();</pre>\n<pre>void longJump();</pre>\n<pre>}</pre>\n<p>We have added the method compete, but also there some extra methods like swim, highJump\u00a0, and longJump.</p>\n<p>Suppose that John Doe is a swimming athlete. By implementing the Athlete interface, we have to implement methods like highJump and longJump, which JohnDoe will never\u00a0use.</p>\n<pre>public class JohnDoe implements Athlete {</pre>\n<pre>@Override<br>    public void compete() {<br>        System.out.println(\"John Doe started competing\");<br>    }</pre>\n<pre>@Override<br>    public void swim() {<br>        System.out.println(\"John Doe started swimming\");<br>    }</pre>\n<pre>@Override<br>    public void highJump() {<br>    }</pre>\n<pre>@Override<br>    public void longJump() {<br>    }<br>}</pre>\n<p>The same problem will occur for another athlete who might be a field Athlete competing in the high jump and long\u00a0jump.</p>\n<p>We will follow the interface segregation principle and refactor the original interface:</p>\n<pre>public interface Athlete {</pre>\n<pre>void compete();<br>}</pre>\n<p>Then we will create two other interfaces\u200a\u2014\u200aone for Jumping athletes and one for Swimming athletes.</p>\n<pre>public interface SwimmingAthlete extends Athlete {</pre>\n<pre>void swim();</pre>\n<pre>}</pre>\n<pre>public interface JumpingAthlete extends Athlete {</pre>\n<pre>void highJump();</pre>\n<pre>void longJump();</pre>\n<pre>}</pre>\n<p>And therefore John Doe will not have to implement actions that he is not capable of performing:</p>\n<pre>public class JohnDoe implements SwimmingAthlete {</pre>\n<pre>@Override<br>    public void compete() {<br>        System.out.println(\"John Doe started competing\");<br>    }</pre>\n<pre>@Override<br>    public void swim() {<br>        System.out.println(\"John Doe started swimming\");<br>    }</pre>\n<pre>}</pre>\n<h4>Summary of Interface Segregation Principle</h4>\n<h3>Dependency Inversion Principle</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/0*BZ0GHAoqIp9eMebg.png\"></figure><p><em>High-level modules should not depend on low-level modules. Both should depend on abstractions.</em></p>\n<p><em>High-level modules should not depend on low-level modules. Both should depend on abstractions.</em></p>\n<ul>\n<li>Entities must depend on abstractions, not on concretions.</li>\n<li>This principle allows for decoupling.</li>\n</ul>\n<p>Here is an example of a PasswordReminder that connects to a MySQL database:</p>\n<pre>class MySQLConnection<br>{<br>    public Connection connect()<br>    {<br>        // handle the database connection<br>        return 'Database connection';<br>    }<br>}</pre>\n<pre>class PasswordReminder<br>{<br>    private MySQLConnection dbConnection;</pre>\n<pre>public void construct(MySQLConnection dbConnection)<br>    {<br>        this.dbConnection = dbConnection;<br>    }<br>}</pre>\n<p>First, the MySQLConnection is the low-level module while the PasswordReminder is high level, but according to the definition of <strong>D</strong> in SOLID, which states to <em>Depend on abstraction, not on concretions</em>. This snippet above violates this principle as the PasswordReminder class is being forced to depend on the MySQLConnection class.</p>\n<p>Later, if you were to change the database engine, you would also have to edit the PasswordReminder class, and this would violate the <em>open-close principle</em>.</p>\n<p>The PasswordReminder class should not care what database your application uses. To address these issues, you can code to an interface since high-level and low-level modules should depend on abstraction:</p>\n<pre>interface DBConnectionInterface<br>{<br>    public Connection connect();<br>}</pre>\n<p>The interface has a connect method and the MySQLConnection class implements this interface. Also, instead of directly type-hinting MySQLConnection class in the constructor of the PasswordReminder, you instead type-hint the DBConnectionInterface and no matter the type of database your application uses, the PasswordReminder class can connect to the database without any problems and open-close principle is not violated.</p>\n<pre>class MySQLConnection implements DBConnectionInterface<br>{<br>    public Connection connect()<br>    {<br>        // handle the database connection<br>        return 'Database connection';<br>    }<br>}</pre>\n<pre>class PasswordReminder<br>{<br>    private DBConnectionInterface dbConnection;</pre>\n<pre>public void construct(DBConnectionInterface dbConnection)<br>    {<br>        this.dbConnection = dbConnection;<br>    }<br>}</pre>\n<p>This code establishes that both the high-level and low-level modules depend on abstraction.</p>\n<h3><strong>Conclusion</strong></h3>\n<ul>\n<li>The <strong>SOLID</strong> principals of OOP will lead you to better quality code which is more testable and easier to maintain.</li>\n<li>A key theme is avoiding tight coupling in your\u00a0code.</li>\n</ul>\n<p>Thanks for reading this blog. Happy Learning!!!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=41a5b3b604eb\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*AOzeP3iVWba5jd5SSj963w.png\"></figure><h3><strong>Introduction</strong></h3>\n<p><strong><em>SOLID</em></strong> is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also known as <a href=\"http://en.wikipedia.org/wiki/Robert_Cecil_Martin\">Uncle\u00a0Bob</a>).</p>\n<p><strong>SOLID</strong> stands\u00a0for:</p>\n<ul>\n<li>\n<strong>S</strong>\u200a\u2014\u200aSingle Responsibility Principle</li>\n<li>\n<strong>O</strong>\u200a\u2014\u200aOpen-closed Principle</li>\n<li>\n<strong>L</strong>\u200a\u2014\u200aLiskov Substitution Principle</li>\n<li>\n<strong>I</strong>\u200a\u2014\u200aInterface Segregation Principle</li>\n<li>\n<strong>D</strong>\u200a\u2014\u200aDependency Inversion Principle</li>\n</ul>\n<h3>Why use the Solid Principles of\u00a0OOP?</h3>\n<ul>\n<li>Object Oriented Programming is a powerful\u00a0concept.</li>\n<li>But, OOP doesn\u2019t always lead to quality software.</li>\n<li>The five principles focus on dependency management.</li>\n<li>Poor Dependency Management leads to code that is brittle, fragile, and hard to\u00a0change.</li>\n<li>Proper dependency management leads to quality code that is easy to maintain.</li>\n</ul>\n<h3>Single Responsibility Principle</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/639/1*4iG1xoSStluQV73wyCQhEw.png\"></figure><p><strong>Single Responsibility Principle states\u00a0that</strong></p>\n<p><em>A class should have one and only one reason to change, meaning that a class should have only one\u00a0job.</em></p>\n<ul>\n<li>Every class should have a single responsibility.</li>\n<li>Classes should be small. No more than a screen full of\u00a0code.</li>\n<li>Avoid <strong>GOD</strong>\u00a0classes</li>\n<li>Split big classes into smaller\u00a0classes.</li>\n</ul>\n<p>Let\u2019s understand with the help of\u00a0code.</p>\n<pre>public class SimpleCalculator{</pre>\n<pre>  public int add(int a , int b){<br>      return a + b;<br>  }</pre>\n<pre>  public int subtract(int a , int b){<br>      return a - b;<br>  }</pre>\n<pre>  public int multiply(int a , int b){<br>      return a * b;<br>  }</pre>\n<pre>  public int divide(int a , int b){<br>      return a/b;<br>  }<br><br>  public void printSum(int sum){<br>      System.out.println(s);<br>  }</pre>\n<pre>}</pre>\n<p>The Simple calculator class violates the rule of SRP. As per the rule a class should have one job to do but the Simple calculator class have two responsibilities <strong>calculating</strong> and <strong>printing</strong> the\u00a0value.</p>\n<p>We should create another class ValuePrinter that handles only printing the\u00a0value.</p>\n<pre>public class ValuePrinter{</pre>\n<pre>public void printSum(int value){<br>      System.out.println(value);<br>  }</pre>\n<pre>}</pre>\n<pre>public class SimpleCalculator{</pre>\n<pre>public int add(int a , int b){<br>      return a + b;<br>  }</pre>\n<pre>public int subtract(int a , int b){<br>      return a - b;<br>  }</pre>\n<pre>public int multiply(int a , int b){<br>      return a * b;<br>  }</pre>\n<pre>public int divide(int a , int b){<br>      return a/b;<br>  }<br>}</pre>\n<p>That satisfies the single-responsibility principle.</p>\n<h3>Open-Closed Principal</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/880/1*sZt3CvVVYLfsuIXIX1yOBA.png\"></figure><p><strong>Open-Closed principle states\u00a0that</strong></p>\n<p><em>Objects or entities should be open for extension but closed for modification.</em></p>\n<ul>\n<li>Classes should be open for extension.</li>\n<li>But close for modification.</li>\n<li>You should be able to extend a classes behavior, without modifying it.</li>\n<li>Use private variables with getters and setters -ONLY when you need\u00a0them.</li>\n<li>Use abstract base\u00a0classes.</li>\n</ul>\n<p>Consider an insurance system that validates health insurance claims before approving one. A <strong>HealthInsuranceSurveyor</strong> class responsible to validate claims and a <strong>ClaimApprovalManager</strong> class responsible to approve\u00a0claims.</p>\n<pre>public class HealthInsuranceSurveyor{</pre>\n<pre>public boolean isValidClaim(){<br>    System.out.println(\"HealthInsuranceSurveyor: Validating health insurance claim...\");<br><br>   return true;</pre>\n<pre> }</pre>\n<pre>public class ClaimApprovalManager{</pre>\n<pre>public void processHeathClaim(HealthInsuranceSurveyor surveyor){<br>       if(surveyor.isValidClaim()){<br>           System.out.println(\"ClaimApprovalManager : Valid claim. <br>Currently processing claim for approval....\");</pre>\n<pre>      }</pre>\n<pre>  }</pre>\n<pre>}</pre>\n<p>Both the <strong>HealthInsuranceSurveyor</strong> and <strong>ClaimApprovalManager</strong> classes work fine and the design for the insurance system appears perfect until a new requirement to process vehicle insurance claims arises.We now need to include a new <strong>VehicleInsuranceSurveyor</strong> class, and this should not create any problems. But, what we also need is to modify the <strong>ClaimApprovalManager</strong> class to process vehicle insurance claims. This is how the modified <strong>ClaimApprovalManager</strong> will\u00a0be:</p>\n<h4>Modified ClaimApprovalManager.java</h4>\n<pre>public class ClaimApprovalManager{</pre>\n<pre>public void processHeathClaim(HealthInsuranceSurveyor surveyor){<br>       if(surveyor.isValidClaim()){<br>           System.out.println(\"ClaimApprovalManager : Valid claim. <br>Currently processing claim for approval....\");</pre>\n<pre>}<br>}<br>public void processVehicleClaim(VehicleInsuranceSurveyor surveyor){<br>     if(surveyor.isValidClaim()){<br>           System.out.println(\"ClaimApprovalManager : Valid claim. <br>Currently processing claim for approval....\");<br>}<br>}<br>}</pre>\n<p>In the example above, we modified the <strong>ClaimApprovalManager</strong> class by adding a new <strong>processVehicleClaim</strong>( ) method to incorporate a new functionality (claim approval of vehicle insurance).This is a clear violation of the Open Closed Principle.</p>\n<p>The ideal approach for the insurance claim example would have been to design the ClaimApprovalManager class in a way that it\u00a0remains:</p>\n<ul>\n<li>\n<strong>Open</strong> to support more types of insurance claims.</li>\n<li>\n<strong>Closed</strong> for any modifications whenever support for a new type of claim is\u00a0added.</li>\n</ul>\n<p>To achieve this, let\u2019s introduce a layer of abstraction by creating an abstract class to represent different claim validation behaviors. We will name the class InsuranceSurveyor.</p>\n<h4>InsuranceSurveyor.java</h4>\n<pre>public abstract class InsuranceSurveyor{<br>  public abstract boolean isValidClaim();<br>}</pre>\n<h4>HealthInsuranceSurveyor.java</h4>\n<pre>public class HealthInsuranceSurveyor extends InsuranceSurveyor{</pre>\n<pre>public boolean isValidClaim(){<br>    System.out.println(\"HealthInsuranceSurveyor: Validating health insurance claim...\");<br><br>   return true;</pre>\n<pre>}</pre>\n<h4>VehicleInsuranceSurveyor.java</h4>\n<pre>public class VehicleInsuranceSurveyor extends InsuranceSurveyor{</pre>\n<pre>public boolean isValidClaim(){<br>    System.out.println(\"VehicleInsuranceSurveyor: Validating vehicle insurance claim...\");<br><br>   return true;</pre>\n<pre>}</pre>\n<h4>ClaimApprovalManager.java</h4>\n<pre>public class ClaimApprovalManager{</pre>\n<pre>public void processHeathClaim(InsuranceSurveyor surveyor){<br>       if(surveyor.isValidClaim()){<br>           System.out.println(\"ClaimApprovalManager : Valid claim. <br>Currently processing claim for approval....\");<br>}<br>}<br>}</pre>\n<p>In the example above, we wrote a processClaim( ) method to accept a InsuranceSurveyor type instead of specifying a concrete type. In this way, any further addition of InsuranceSurveyor implementations will not affect the ClaimApprovalManager class. Our insurance system is now <strong>open</strong> to support more types of insurance claims, and <strong>closed</strong> for any modifications whenever a new claim type is\u00a0added.</p>\n<h3>Liskov Substitution Principle</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/656/1*q5JKXx_aLaulkqTxM77guw.png\"></figure><p><em>The principal defines that objects of a superclass shall be replaceable with object of its subclasses without breaking the application.</em></p>\n<ul>\n<li>That requires the objects of your subclasses to behave in the same way as the objects of your superclass.</li>\n<li>It means that we must make sure that new derived classes are extending the base classes without changing their behavior.</li>\n<li>It is an extension of Open Closed Principal.</li>\n<li>This principal helps you to implement OCP correctly.</li>\n</ul>\n<p>Let\u2019s take an example to understand it\u00a0better</p>\n<ol>\n<li>Calculate Area of Rectangle.</li>\n<li>Calculate Area of Square as\u00a0well</li>\n</ol>\n<p>As we know, <strong>Square is a Rectangle</strong> and if we talk about inheritance it is also be read as \u201c<strong>IS A</strong>\u201d relationship.</p>\n<p>So, we can create Rectangle as a base or super class and Square as sub\u00a0class.</p>\n<p><strong>Rectangle.java</strong></p>\n<pre>public class Rectangle {</pre>\n<pre> protected int width;<br> protected int height;</pre>\n<pre>public int getWidth(){<br>   return this.width;<br> }</pre>\n<pre>public int getHeight(){<br>   return this.height;<br> }<br><br>public void setHeight(int height){<br>  this.height = height;<br>}</pre>\n<pre>public void setWidth(int width){<br>  this.width = width;<br>}</pre>\n<pre>public int getArea(){<br> return this.height * this.width;<br>}<br>}</pre>\n<p><strong>Square.java</strong></p>\n<pre>public class Square extends Rectangle{ <br><br>public void setHeight(int height){<br>  this.height = height;<br>  this.width = height;</pre>\n<pre>}</pre>\n<pre>public void setWidth(int width){<br>  this.width = width;<br>  this.height = width;<br>}<br>}</pre>\n<p><strong>CalculateRectangleArea.java</strong></p>\n<pre>public class CalculateRectangleArea{</pre>\n<pre>public static void main(String[] args){<br><br>  Rectangle rect = new Rectangle();<br>  rect.setWidth(2);<br>  rect.setHeight(3);</pre>\n<pre>  System.out.println(\"Area of rectangle : \" + rect.getArea());</pre>\n<pre>}<br>}</pre>\n<pre>Output : <br>Area of rectangle : 6</pre>\n<p><strong>CalculateSquareArea.java</strong></p>\n<pre>public class CalculateSquareArea{</pre>\n<pre>public static void main(String[] args){<br><br>  Rectangle square = new Square();<br>  square.setWidth(2);<br>  square.setHeight(3);</pre>\n<pre>System.out.println(\"Area of square: \" + square.getArea());</pre>\n<pre>}<br>}</pre>\n<pre>Output : <br>Area of square : 9</pre>\n<p>Now, if we change the order of setWidth and setHeight method</p>\n<pre>public class CalculateSquareArea{</pre>\n<pre>public static void main(String[] args){<br><br>  Rectangle square = new Square();<br>  square.setHeight(3);<br>  square.setWidth(2);</pre>\n<pre>System.out.println(\"Area of square is : \" + square.getArea());</pre>\n<pre>}<br>}</pre>\n<pre>Output : <br>Area of square is : 4</pre>\n<p>The output after changing the order of method is not same\u00a0, so the above code violates the LSP principle i.e \u201c <em>The objects of your subclasses to behave in the same way as the objects of your superclass</em>\u201d.</p>\n<p><strong>How to identify violation of\u00a0LSP.</strong></p>\n<ul>\n<li>A not implemented method in the subclass.</li>\n<li>Subclass function overrides the base class method to give it new\u00a0meaning.</li>\n</ul>\n<p>Let\u2019s implement the LSP in the correct\u00a0manner.</p>\n<p><strong>Shape.java</strong></p>\n<pre>public abstract class Shape {<br> abstract public int getArea();<br>}</pre>\n<p><strong>Rectangle.java</strong></p>\n<pre>public class Rectangle extends Shape{</pre>\n<pre>protected int width;<br> protected int height;</pre>\n<pre>public int getWidth(){<br>   return this.width;<br> }</pre>\n<pre>public int getHeight(){<br>   return this.height;<br> }<br><br>public void setHeight(int height){<br>  this.height = height;<br>}</pre>\n<pre>public void setWidth(int width){<br>  this.width = width;<br>}</pre>\n<pre>@Override<br>public int getArea(){<br> return this.height * this.width;<br>}<br>}</pre>\n<p><strong>Square.java</strong></p>\n<pre>public class Square extends Shape{</pre>\n<pre>int length;</pre>\n<pre>public int getLength(){<br>   return this.length;<br> }<br><br>public void setLength(int length){<br>  this.length = length;<br>}</pre>\n<pre>@Override<br>public int getArea(){<br> return this.length * this.length;<br>}<br>}</pre>\n<p><strong>CalculateRectangleArea.java</strong></p>\n<pre>public class CalculateRectangleArea{</pre>\n<pre>public static void main(String[] args){<br><br>  Shape rect = new Rectangle();<br>  rect.setWidth(2);<br>  rect.setHeight(3);</pre>\n<pre>System.out.println(\"Area of rectangle : \" + rect.getArea());</pre>\n<pre>}<br>}</pre>\n<pre>Output : <br>Area of rectangle : 6</pre>\n<p><strong>CalculateSquareArea.java</strong></p>\n<pre>public class CalculateSquareArea{</pre>\n<pre>public static void main(String[] args){<br><br>  Shape square = new Square();<br>  square.setLength(2);</pre>\n<pre>System.out.println(\"Area of square : \" + square.getArea());</pre>\n<pre>}<br>}</pre>\n<pre>Output : <br>Area of square : 4</pre>\n<p><strong>Why we shouldn\u2019t violate\u00a0LSP.</strong></p>\n<ul>\n<li>The use of using abstract base class is that, in future, you can write a new subclass and insert it into existing, working, tested\u00a0code.</li>\n<li>The essence of the Open Closed Principal.</li>\n<li>However, when the subclasses don\u2019t adhere properly to the behavior of the base class, you have to go through the existing code and modify the subclasses accordingly.</li>\n<li>This is a blatant violation of the Open Closed Principal.</li>\n</ul>\n<h3>Interface Segregation Principle</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/1*5yfkFXUx_qJy7JsH3P-lzg.png\"></figure><p><em>This principle states that \u201cClients should not be forced to depend on methods that they do not use\u201d. Here, the term \u201cClients\u201d refers to the implementing classes of an interface.</em></p>\n<p>The <strong>Interface Segregation Principle</strong> advocates segregating a \u201cfat interface\u201d into smaller and <a href=\"https://en.wikipedia.org/wiki/Cohesion_%28computer_science%29\">highly cohesive</a> interfaces, known as \u201crole interfaces\u201d. Each \u201crole interface\u201d declares one or more methods for a specific behavior. Thus clients, instead of implementing a \u201cfat interface\u201d, can implement only those \u201crole interfaces\u201d whose methods are relevant to\u00a0them.</p>\n<h4>Interface Segregation Principle Violation (Bad Example):</h4>\n<p>Let\u2019s consider an example, the Athlete interface is an interface with some actions of an\u00a0athlete:</p>\n<pre>public interface Athlete {</pre>\n<pre>void compete();</pre>\n<pre>void swim();</pre>\n<pre>void highJump();</pre>\n<pre>void longJump();</pre>\n<pre>}</pre>\n<p>We have added the method compete, but also there some extra methods like swim, highJump\u00a0, and longJump.</p>\n<p>Suppose that John Doe is a swimming athlete. By implementing the Athlete interface, we have to implement methods like highJump and longJump, which JohnDoe will never\u00a0use.</p>\n<pre>public class JohnDoe implements Athlete {</pre>\n<pre>@Override<br>    public void compete() {<br>        System.out.println(\"John Doe started competing\");<br>    }</pre>\n<pre>@Override<br>    public void swim() {<br>        System.out.println(\"John Doe started swimming\");<br>    }</pre>\n<pre>@Override<br>    public void highJump() {<br>    }</pre>\n<pre>@Override<br>    public void longJump() {<br>    }<br>}</pre>\n<p>The same problem will occur for another athlete who might be a field Athlete competing in the high jump and long\u00a0jump.</p>\n<p>We will follow the interface segregation principle and refactor the original interface:</p>\n<pre>public interface Athlete {</pre>\n<pre>void compete();<br>}</pre>\n<p>Then we will create two other interfaces\u200a\u2014\u200aone for Jumping athletes and one for Swimming athletes.</p>\n<pre>public interface SwimmingAthlete extends Athlete {</pre>\n<pre>void swim();</pre>\n<pre>}</pre>\n<pre>public interface JumpingAthlete extends Athlete {</pre>\n<pre>void highJump();</pre>\n<pre>void longJump();</pre>\n<pre>}</pre>\n<p>And therefore John Doe will not have to implement actions that he is not capable of performing:</p>\n<pre>public class JohnDoe implements SwimmingAthlete {</pre>\n<pre>@Override<br>    public void compete() {<br>        System.out.println(\"John Doe started competing\");<br>    }</pre>\n<pre>@Override<br>    public void swim() {<br>        System.out.println(\"John Doe started swimming\");<br>    }</pre>\n<pre>}</pre>\n<h4>Summary of Interface Segregation Principle</h4>\n<h3>Dependency Inversion Principle</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/0*BZ0GHAoqIp9eMebg.png\"></figure><p><em>High-level modules should not depend on low-level modules. Both should depend on abstractions.</em></p>\n<p><em>High-level modules should not depend on low-level modules. Both should depend on abstractions.</em></p>\n<ul>\n<li>Entities must depend on abstractions, not on concretions.</li>\n<li>This principle allows for decoupling.</li>\n</ul>\n<p>Here is an example of a PasswordReminder that connects to a MySQL database:</p>\n<pre>class MySQLConnection<br>{<br>    public Connection connect()<br>    {<br>        // handle the database connection<br>        return 'Database connection';<br>    }<br>}</pre>\n<pre>class PasswordReminder<br>{<br>    private MySQLConnection dbConnection;</pre>\n<pre>public void construct(MySQLConnection dbConnection)<br>    {<br>        this.dbConnection = dbConnection;<br>    }<br>}</pre>\n<p>First, the MySQLConnection is the low-level module while the PasswordReminder is high level, but according to the definition of <strong>D</strong> in SOLID, which states to <em>Depend on abstraction, not on concretions</em>. This snippet above violates this principle as the PasswordReminder class is being forced to depend on the MySQLConnection class.</p>\n<p>Later, if you were to change the database engine, you would also have to edit the PasswordReminder class, and this would violate the <em>open-close principle</em>.</p>\n<p>The PasswordReminder class should not care what database your application uses. To address these issues, you can code to an interface since high-level and low-level modules should depend on abstraction:</p>\n<pre>interface DBConnectionInterface<br>{<br>    public Connection connect();<br>}</pre>\n<p>The interface has a connect method and the MySQLConnection class implements this interface. Also, instead of directly type-hinting MySQLConnection class in the constructor of the PasswordReminder, you instead type-hint the DBConnectionInterface and no matter the type of database your application uses, the PasswordReminder class can connect to the database without any problems and open-close principle is not violated.</p>\n<pre>class MySQLConnection implements DBConnectionInterface<br>{<br>    public Connection connect()<br>    {<br>        // handle the database connection<br>        return 'Database connection';<br>    }<br>}</pre>\n<pre>class PasswordReminder<br>{<br>    private DBConnectionInterface dbConnection;</pre>\n<pre>public void construct(DBConnectionInterface dbConnection)<br>    {<br>        this.dbConnection = dbConnection;<br>    }<br>}</pre>\n<p>This code establishes that both the high-level and low-level modules depend on abstraction.</p>\n<h3><strong>Conclusion</strong></h3>\n<ul>\n<li>The <strong>SOLID</strong> principals of OOP will lead you to better quality code which is more testable and easier to maintain.</li>\n<li>A key theme is avoiding tight coupling in your\u00a0code.</li>\n</ul>\n<p>Thanks for reading this blog. Happy Learning!!!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=41a5b3b604eb\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["design-patterns","software-development","technology","software-architecture"]},{"title":"Java Modularity","pubDate":"2021-08-21 17:10:33","link":"https://medium.com/@sanjayofficial94/java-modularity-a848942d0820?source=rss-dfd30b357e8c------2","guid":"https://medium.com/p/a848942d0820","author":"Sanjay Mehta","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/518/1*fSeR3DKpocfbYykT3FRsRQ.png\"></figure><blockquote>\n<strong>Modularity</strong> is a general concept which applies to the development of software in a fashion which allows individual <em>modules</em> to be developed, often with a standardized interface to allow modules to communicate. In fact, the kind of separation of concerns between objects in an OO language is much the same concept as for modules, except on a larger scale. Typically, partitioning a system into modules helps minimize <a href=\"http://en.wikipedia.org/wiki/Coupling_(computer_science)\">coupling</a>, which should lead to easier to maintain\u00a0code.</blockquote>\n<h3>Why do we need Java modularity?</h3>\n<p><strong>The JDK before Java SE\u00a09</strong></p>\n<p>1\u00a0. The JDK was huge and monolithic.</p>\n<p>2. This resulted in increased\u2026<br>\u200a\u2014\u200aDownload Time<br>\u200a\u2014\u200aStartup Time<br>\u200a\u2014\u200aMemory Footprint</p>\n<p><strong>The Modular\u00a0JDK</strong></p>\n<ol><li>With <strong>Java</strong> SE 9\u00a0, the monolithic <strong>JDK</strong> was broken into 90\u00a0modules.</li></ol>\n<p>2. Every module is a well defined piece of functionality.<br>\u200a\u2014\u200aSimilar packages and frameworks are grouped into their own modules.<br> For example: Logging\u00a0, Swing and Instrumentation.<br>\u200a\u2014\u200aBe aware of modules for significant API\u00a0, not trivial\u00a0ones.</p>\n<p>3. Benefits Include:<br>\u200a\u2014\u200aApplications which are more scalable to small devices.<br>\u200a\u2014\u200aImproved application perfomance<br>\u200a\u2014\u200aImproved security and maintainability(for Java and your\u00a0apps)</p>\n<p><strong>Listing the modules in Java\u00a09</strong></p>\n<pre>$java --list-modules</pre>\n<h3><strong>Java SE\u00a0Modules</strong></h3>\n<p>These Modules are classified into two categories:</p>\n<ol>\n<li>Standard modules( java.* prefix for module names):<br>\u200a\u2014\u200aPart of the Java SE specification<br>\u200a\u2014\u200aFor example: java.sql for database connectivity, java.xml for XML processing\u00a0, and java.logging for\u00a0logging</li>\n<li>Modules not defined in the Java SE platform(jdk.* prefix for module names):<br>\u200a\u2014\u200aAre specific to the JDK<br>\u200a\u2014\u200aFor example: jdk.jshell\u00a0, jdk.policytool, jdk.httpserver</li>\n</ol>\n<h3>What\u2019s Inside a\u00a0Module?</h3>\n<ul>\n<li>A module is a set of exported packages and concealed packages.</li>\n<li>\n<strong>public</strong> no longer means \u201caccessible to everyone\u201d.</li>\n<li>You may set up modules to encapsulate your own\u00a0code.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*2bDBe_YSqaiqD-J8MdNf8g.jpeg\"></figure><p><strong>Accessibility( JDK 9 and\u00a0later)</strong></p>\n<ul>\n<li>public <strong>to\u00a0everyone</strong>\n</li>\n<li>public, <strong>but only to specific\u00a0modules</strong>\n</li>\n<li>public <strong>only within a\u00a0module</strong>\n</li>\n<li>protected</li>\n<li><strong>&lt;package&gt;</strong></li>\n<li>private</li>\n</ul>\n<h3><strong>module-info.java</strong></h3>\n<ul>\n<li>A module is declared with a <strong>module-info.java</strong> file.</li>\n<li>Declarations begin with the keyword <strong>module</strong>, followed by a unique module name and a module body enclosed in\u00a0braces.</li>\n<li>Add directives such as <strong>requires</strong>\u00a0, <strong>exports</strong> to specify accessibility between modules.<br>\u200a\u2014\u200aWhat packages the module makes available to other modules?<br>\u200a\u2014\u200aWhere a package is exported to?<br>\u200a\u2014\u200aWhat outside modules it\u2019s dependent on?</li>\n</ul>\n<pre>module modulename {</pre>\n<pre>}</pre>\n<h3>Creating a Modular\u00a0Project</h3>\n<ul>\n<li>Name of the\u00a0project</li>\n<li>Place module-info.java in the root directory of the packages that you want to group as a\u00a0module.</li>\n<li>NetBeans marks this as the default\u00a0package.</li>\n<li>One modular JAR is produced for every\u00a0module.</li>\n</ul>\n<p>\u2014 <strong>Modular</strong> JARs become the unit of release and\u00a0reuse.</p>\n<p>\u2014 They\u2019re intended to contain a very specific set of functionality.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/304/1*SGmM8VthZXBP2PYxtvkk4w.png\"><figcaption>Modules-Project</figcaption></figure><h3>\n<strong>exports </strong>Module Directive</h3>\n<ul>\n<li>Declares a package is accessible to code in all other modules.<br>\u200a\u2014\u200aIncludes access to the package\u2019s public classes\u00a0, fields\u00a0, and methods.<br>\u200a\u2014\u200aExcludes access to anything with private\u00a0, protected, or package\u00a0access.</li>\n<li>Use the exports statement judiciously.<br>\u200a\u2014\u200aYou\u2019ll never be certain how someone else wants to use your module.<br>\u200a\u2014\u200aExport only those packages that you feel are safe.<br>\u200a\u2014\u200aModularity is about future-proofing</li>\n</ul>\n<pre>module A {<br>  exports pkgA;</pre>\n<pre>}</pre>\n<h3>exports\u2026to Module Directive</h3>\n<ul>\n<li>Declare a package is accessible to code in specific modules<br>\u200a\u2014\u200aIncludes access to the package\u2019s public classes, fields, and methods<br>\u200a\u2014\u200aExcludes access to anything with private, protected, or package access<br>\u200a\u2014\u200aExcludes access from any module not specified</li>\n<li>Use a specifies a comma-separated list to specify many modules to export\u00a0to.</li>\n<li>This is known as a qualified export.</li>\n</ul>\n<pre>module A {<br>    exports pkgA to B, C;<br>}</pre>\n<h3>requires Module Directive</h3>\n<ul>\n<li>Declares the module is dependent on another module<br>\u200a\u2014\u200aOnly exported packages are readable by the requiring module.<br>\u200a\u2014\u200aPackages that aren\u2019t exported aren\u2019t readable.<br>\u200a\u2014\u200aAnything nonpublic is not readable, even from exported packages.</li>\n<li>Classes within the current module may require a class, instance, or method written in another\u00a0module.</li>\n</ul>\n<pre>module B {<br>    requires A;<br>}</pre>\n<h3><strong>Example</strong></h3>\n<pre>package pkgA;</pre>\n<pre>public class ClassA{<br>  public int yearPublic = 2001;<br>  protected int yearProtected = 2002;<br>  int yearPackage = 2003;<br>  private int yearPrivate = 2004;<br>}</pre>\n<pre>module A {<br>    exports pkgA;<br>}</pre>\n<pre>module B {<br>   requires A;<br>}</pre>\n<pre>package pkgB;</pre>\n<pre>import pkgA.ClassA; </pre>\n<pre>public class NewMain{<br>  public static void main(String[] args){<br>    ClassA test = new ClassA();<br>     System.out.println(test.yearPublic); //Yes<br>     System.out.println(test.yearProtected); //No<br>     System.out.println(test.yearPackage); //No<br>     System.out.println(test.yearPrivate); //No<br>}}</pre>\n<h3>requires transitive Module Directive</h3>\n<ul>\n<li>Transitivity allows readability up the requirement chain.</li>\n<li>Anything requiring the current module has access to:<br>\u200a\u2014\u200aPackages exported by the current module<br>\u200a\u2014\u200aPackages exported by anything the current module requires transitively</li>\n<li>Known as \u201cimplied readability\u201d</li>\n</ul>\n<h3>Example</h3>\n<pre>module C{<br>  exports pkgC;<br>}<br></pre>\n<pre>package pkgC;</pre>\n<pre>public class ClassC {<br>   public static String transitiveVar;<br>   transitiveVar = \"From C\";<br>}<br></pre>\n<pre>module A{<br><strong>requires transitive</strong> C;<br>  exports pkgA to B;<br>}<br></pre>\n<pre>module B {<br>   requires A;<br>}<br></pre>\n<pre>package pkgB;</pre>\n<pre>import pkgA.ClassA;<br>import pkgC.ClassC;</pre>\n<pre>public class NewMain{<br>  public static void main(String[] args){<br>    ClassA test = new ClassA();<br>    System.out.println(test.yearPublic);<br>    System.out.println(ClassC.transitiveVar);<br>}<br>}</pre>\n<h3>The Base Module java.base</h3>\n<ul>\n<li>The base module exports all of the platform\u2019s core packages.</li>\n<li>Every module depends on <strong>java.base</strong>.</li>\n<li>\n<strong>java.base</strong> doesn\u2019t depend on any other\u00a0modules.</li>\n<li>The<strong> java.base</strong> module reference is implicitly included in all other\u00a0modules.</li>\n</ul>\n<pre>// module-info.java</pre>\n<pre>module java.base{<br>  exports java.lang;<br>  exports java.io;<br>  exports java.net;<br>  exports java.util;<br>}</pre>\n<pre>module A{<br><strong>requires java.base</strong>;   // <strong>implied</strong><br>  requires java.logging;<br>  requires transitive C;<br>  exports pkgA to B;<br>}</pre>\n<h3><strong>Summary of\u00a0Keywords</strong></h3>\n<p><strong>Keywords and Syntax with Description</strong></p>\n<ol>\n<li>\n<strong>export &lt;package&gt;</strong><br>\u200a\u2014\u200aDeclares which package is eligible to be\u00a0read.</li>\n<li>\n<strong>export &lt;package&gt; to &lt;module&gt;<br></strong>\u200a\u2014\u200aDeclares which package is eligible to be read by a specific\u00a0module</li>\n<li>\n<strong>requires &lt;module&gt;<br>\u200a</strong>\u2014\u200aSpecifies another module to read\u00a0from</li>\n<li>\n<strong>requires transitive &lt;module&gt;<br>\u200a</strong>\u2014\u200aSpecifies another module to read from. The relationship is transitive where indirect. access is given to modules requiring the current\u00a0module.</li>\n</ol>\n<ul>\n<li>These are restricted keywords</li>\n<li>Their creation won\u2019t break existing\u00a0code.</li>\n<li>They\u2019re only available in the context of the <strong>module-info</strong> class.</li>\n</ul>\n<p>If you have questions or comments about this let me know in the comments below. You can view the full code\u00a0here:</p>\n<p><a href=\"https://github.com/zsanjay/Java-9-Modules\">GitHub - zsanjay/Java-9-Modules</a></p>\n<p>Thanks for reading this blog. Happy Learning!!!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a848942d0820\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/518/1*fSeR3DKpocfbYykT3FRsRQ.png\"></figure><blockquote>\n<strong>Modularity</strong> is a general concept which applies to the development of software in a fashion which allows individual <em>modules</em> to be developed, often with a standardized interface to allow modules to communicate. In fact, the kind of separation of concerns between objects in an OO language is much the same concept as for modules, except on a larger scale. Typically, partitioning a system into modules helps minimize <a href=\"http://en.wikipedia.org/wiki/Coupling_(computer_science)\">coupling</a>, which should lead to easier to maintain\u00a0code.</blockquote>\n<h3>Why do we need Java modularity?</h3>\n<p><strong>The JDK before Java SE\u00a09</strong></p>\n<p>1\u00a0. The JDK was huge and monolithic.</p>\n<p>2. This resulted in increased\u2026<br>\u200a\u2014\u200aDownload Time<br>\u200a\u2014\u200aStartup Time<br>\u200a\u2014\u200aMemory Footprint</p>\n<p><strong>The Modular\u00a0JDK</strong></p>\n<ol><li>With <strong>Java</strong> SE 9\u00a0, the monolithic <strong>JDK</strong> was broken into 90\u00a0modules.</li></ol>\n<p>2. Every module is a well defined piece of functionality.<br>\u200a\u2014\u200aSimilar packages and frameworks are grouped into their own modules.<br> For example: Logging\u00a0, Swing and Instrumentation.<br>\u200a\u2014\u200aBe aware of modules for significant API\u00a0, not trivial\u00a0ones.</p>\n<p>3. Benefits Include:<br>\u200a\u2014\u200aApplications which are more scalable to small devices.<br>\u200a\u2014\u200aImproved application perfomance<br>\u200a\u2014\u200aImproved security and maintainability(for Java and your\u00a0apps)</p>\n<p><strong>Listing the modules in Java\u00a09</strong></p>\n<pre>$java --list-modules</pre>\n<h3><strong>Java SE\u00a0Modules</strong></h3>\n<p>These Modules are classified into two categories:</p>\n<ol>\n<li>Standard modules( java.* prefix for module names):<br>\u200a\u2014\u200aPart of the Java SE specification<br>\u200a\u2014\u200aFor example: java.sql for database connectivity, java.xml for XML processing\u00a0, and java.logging for\u00a0logging</li>\n<li>Modules not defined in the Java SE platform(jdk.* prefix for module names):<br>\u200a\u2014\u200aAre specific to the JDK<br>\u200a\u2014\u200aFor example: jdk.jshell\u00a0, jdk.policytool, jdk.httpserver</li>\n</ol>\n<h3>What\u2019s Inside a\u00a0Module?</h3>\n<ul>\n<li>A module is a set of exported packages and concealed packages.</li>\n<li>\n<strong>public</strong> no longer means \u201caccessible to everyone\u201d.</li>\n<li>You may set up modules to encapsulate your own\u00a0code.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*2bDBe_YSqaiqD-J8MdNf8g.jpeg\"></figure><p><strong>Accessibility( JDK 9 and\u00a0later)</strong></p>\n<ul>\n<li>public <strong>to\u00a0everyone</strong>\n</li>\n<li>public, <strong>but only to specific\u00a0modules</strong>\n</li>\n<li>public <strong>only within a\u00a0module</strong>\n</li>\n<li>protected</li>\n<li><strong>&lt;package&gt;</strong></li>\n<li>private</li>\n</ul>\n<h3><strong>module-info.java</strong></h3>\n<ul>\n<li>A module is declared with a <strong>module-info.java</strong> file.</li>\n<li>Declarations begin with the keyword <strong>module</strong>, followed by a unique module name and a module body enclosed in\u00a0braces.</li>\n<li>Add directives such as <strong>requires</strong>\u00a0, <strong>exports</strong> to specify accessibility between modules.<br>\u200a\u2014\u200aWhat packages the module makes available to other modules?<br>\u200a\u2014\u200aWhere a package is exported to?<br>\u200a\u2014\u200aWhat outside modules it\u2019s dependent on?</li>\n</ul>\n<pre>module modulename {</pre>\n<pre>}</pre>\n<h3>Creating a Modular\u00a0Project</h3>\n<ul>\n<li>Name of the\u00a0project</li>\n<li>Place module-info.java in the root directory of the packages that you want to group as a\u00a0module.</li>\n<li>NetBeans marks this as the default\u00a0package.</li>\n<li>One modular JAR is produced for every\u00a0module.</li>\n</ul>\n<p>\u2014 <strong>Modular</strong> JARs become the unit of release and\u00a0reuse.</p>\n<p>\u2014 They\u2019re intended to contain a very specific set of functionality.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/304/1*SGmM8VthZXBP2PYxtvkk4w.png\"><figcaption>Modules-Project</figcaption></figure><h3>\n<strong>exports </strong>Module Directive</h3>\n<ul>\n<li>Declares a package is accessible to code in all other modules.<br>\u200a\u2014\u200aIncludes access to the package\u2019s public classes\u00a0, fields\u00a0, and methods.<br>\u200a\u2014\u200aExcludes access to anything with private\u00a0, protected, or package\u00a0access.</li>\n<li>Use the exports statement judiciously.<br>\u200a\u2014\u200aYou\u2019ll never be certain how someone else wants to use your module.<br>\u200a\u2014\u200aExport only those packages that you feel are safe.<br>\u200a\u2014\u200aModularity is about future-proofing</li>\n</ul>\n<pre>module A {<br>  exports pkgA;</pre>\n<pre>}</pre>\n<h3>exports\u2026to Module Directive</h3>\n<ul>\n<li>Declare a package is accessible to code in specific modules<br>\u200a\u2014\u200aIncludes access to the package\u2019s public classes, fields, and methods<br>\u200a\u2014\u200aExcludes access to anything with private, protected, or package access<br>\u200a\u2014\u200aExcludes access from any module not specified</li>\n<li>Use a specifies a comma-separated list to specify many modules to export\u00a0to.</li>\n<li>This is known as a qualified export.</li>\n</ul>\n<pre>module A {<br>    exports pkgA to B, C;<br>}</pre>\n<h3>requires Module Directive</h3>\n<ul>\n<li>Declares the module is dependent on another module<br>\u200a\u2014\u200aOnly exported packages are readable by the requiring module.<br>\u200a\u2014\u200aPackages that aren\u2019t exported aren\u2019t readable.<br>\u200a\u2014\u200aAnything nonpublic is not readable, even from exported packages.</li>\n<li>Classes within the current module may require a class, instance, or method written in another\u00a0module.</li>\n</ul>\n<pre>module B {<br>    requires A;<br>}</pre>\n<h3><strong>Example</strong></h3>\n<pre>package pkgA;</pre>\n<pre>public class ClassA{<br>  public int yearPublic = 2001;<br>  protected int yearProtected = 2002;<br>  int yearPackage = 2003;<br>  private int yearPrivate = 2004;<br>}</pre>\n<pre>module A {<br>    exports pkgA;<br>}</pre>\n<pre>module B {<br>   requires A;<br>}</pre>\n<pre>package pkgB;</pre>\n<pre>import pkgA.ClassA; </pre>\n<pre>public class NewMain{<br>  public static void main(String[] args){<br>    ClassA test = new ClassA();<br>     System.out.println(test.yearPublic); //Yes<br>     System.out.println(test.yearProtected); //No<br>     System.out.println(test.yearPackage); //No<br>     System.out.println(test.yearPrivate); //No<br>}}</pre>\n<h3>requires transitive Module Directive</h3>\n<ul>\n<li>Transitivity allows readability up the requirement chain.</li>\n<li>Anything requiring the current module has access to:<br>\u200a\u2014\u200aPackages exported by the current module<br>\u200a\u2014\u200aPackages exported by anything the current module requires transitively</li>\n<li>Known as \u201cimplied readability\u201d</li>\n</ul>\n<h3>Example</h3>\n<pre>module C{<br>  exports pkgC;<br>}<br></pre>\n<pre>package pkgC;</pre>\n<pre>public class ClassC {<br>   public static String transitiveVar;<br>   transitiveVar = \"From C\";<br>}<br></pre>\n<pre>module A{<br><strong>requires transitive</strong> C;<br>  exports pkgA to B;<br>}<br></pre>\n<pre>module B {<br>   requires A;<br>}<br></pre>\n<pre>package pkgB;</pre>\n<pre>import pkgA.ClassA;<br>import pkgC.ClassC;</pre>\n<pre>public class NewMain{<br>  public static void main(String[] args){<br>    ClassA test = new ClassA();<br>    System.out.println(test.yearPublic);<br>    System.out.println(ClassC.transitiveVar);<br>}<br>}</pre>\n<h3>The Base Module java.base</h3>\n<ul>\n<li>The base module exports all of the platform\u2019s core packages.</li>\n<li>Every module depends on <strong>java.base</strong>.</li>\n<li>\n<strong>java.base</strong> doesn\u2019t depend on any other\u00a0modules.</li>\n<li>The<strong> java.base</strong> module reference is implicitly included in all other\u00a0modules.</li>\n</ul>\n<pre>// module-info.java</pre>\n<pre>module java.base{<br>  exports java.lang;<br>  exports java.io;<br>  exports java.net;<br>  exports java.util;<br>}</pre>\n<pre>module A{<br><strong>requires java.base</strong>;   // <strong>implied</strong><br>  requires java.logging;<br>  requires transitive C;<br>  exports pkgA to B;<br>}</pre>\n<h3><strong>Summary of\u00a0Keywords</strong></h3>\n<p><strong>Keywords and Syntax with Description</strong></p>\n<ol>\n<li>\n<strong>export &lt;package&gt;</strong><br>\u200a\u2014\u200aDeclares which package is eligible to be\u00a0read.</li>\n<li>\n<strong>export &lt;package&gt; to &lt;module&gt;<br></strong>\u200a\u2014\u200aDeclares which package is eligible to be read by a specific\u00a0module</li>\n<li>\n<strong>requires &lt;module&gt;<br>\u200a</strong>\u2014\u200aSpecifies another module to read\u00a0from</li>\n<li>\n<strong>requires transitive &lt;module&gt;<br>\u200a</strong>\u2014\u200aSpecifies another module to read from. The relationship is transitive where indirect. access is given to modules requiring the current\u00a0module.</li>\n</ol>\n<ul>\n<li>These are restricted keywords</li>\n<li>Their creation won\u2019t break existing\u00a0code.</li>\n<li>They\u2019re only available in the context of the <strong>module-info</strong> class.</li>\n</ul>\n<p>If you have questions or comments about this let me know in the comments below. You can view the full code\u00a0here:</p>\n<p><a href=\"https://github.com/zsanjay/Java-9-Modules\">GitHub - zsanjay/Java-9-Modules</a></p>\n<p>Thanks for reading this blog. Happy Learning!!!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a848942d0820\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["java","blog","technology"]},{"title":"Promise vs Observable","pubDate":"2021-08-16 19:48:14","link":"https://medium.com/@sanjayofficial94/promise-vs-observable-7c1af6fefd12?source=rss-dfd30b357e8c------2","guid":"https://medium.com/p/7c1af6fefd12","author":"Sanjay Mehta","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*A09g76kdTMW6XOSEbTXw3w.jpeg\"></figure><p>There has been an on-going debate in the world of developers, and that is which is better: JavaScript <strong>Promises</strong> or RxJS <strong>Observables</strong>? Each one can bring so much value to different projects. It\u2019s a good idea to have a good understanding of each and how it could benefit a project. But before we start looking at some comparisons, let\u2019s do a quick overview of what each one\u00a0is.</p>\n<h3><strong>What is a\u00a0Promise</strong></h3>\n<p>A <strong><em>promise</em></strong> is an object that encapsulates the result of an asynchronous operation.</p>\n<p>Each promise has state, which can have one of the following values:</p>\n<ul>\n<li><em>Pending</em></li>\n<li>\n<em>Fulfilled</em> with a\u00a0value</li>\n<li>\n<em>Rejected</em> for a\u00a0reason</li>\n</ul>\n<p>The just created promise is in a <em>pending</em> state. The promise maintains the <em>pending</em> state as long as the asynchronous operation behind is in progress.</p>\n<p>Then, depending on how the asynchronous operation completes, the promise state changes to\u00a0either:</p>\n<p>A) <em>fulfilled</em> (when the async operation completed successfully)</p>\n<p>B) or <em>rejected</em> (when then async operation failed).</p>\n<p>In JavaScript, you can create a promise object using a special constructor</p>\n<pre>const promise = new Promise((resolve, reject) =&gt; {<br>  // Async operation logic here....<br>  if (asyncOperationSuccess) {<br>    resolve(value); // async operation successful<br>  } else {<br>    reject(error);  // async operation error<br>  }<br>});</pre>\n<h3><strong>What is Observable</strong></h3>\n<p><strong><em>Observable</em></strong> are just that\u200a\u2014\u200athings you wish to observe and take action on. Angular uses the <strong>Observer pattern</strong> which simply means\u200a\u2014\u200aObservable objects are registered, and other objects observe (in Angular using the subscribe method) them and take action when the observable object is acted on in some\u00a0way.</p>\n<p>To use observable, Angular uses a third-party library called Reactive Extensions (<strong>RxJS</strong>).</p>\n<p>Let\u2019s take a look how can we use <strong><em>Observable</em></strong> in our Angular application.</p>\n<pre>import { Observable } from 'rxjs/Observable';</pre>\n<pre>// Create simple observable that emits three values <br>   const myObservable = Observable.of(1, 2, 3); </pre>\n<pre>// Create observer object <br>   const myObserver = { <br>next: x =&gt; console.log('Observer got a next value: ' + x),             error: err =&gt; console.error('Observer got an error: ' + err),          complete: () =&gt; console.log('Observer got a complete notification')<br> };         </pre>\n<pre>// Execute with the observer object    myObservable.subscribe(myObserver);  </pre>\n<pre>  // Logs:   <br> // Observer got a next value: 1   <br> // Observer got a next value: 2    <br>// Observer got a next value: 3    <br>// Observer got a complete notification</pre>\n<p>Here are the main differences which is covered in this blog\u00a0post:</p>\n<h3>Eager vs\u00a0Lazy</h3>\n<p><strong>Promise is eager\u00a0, </strong>hence<strong> </strong>execute immediately, and just once. The computation of the result is initiated when the promise is created. There is no way to restart work. All then clauses (subscriptions) share the same computation.</p>\n<pre>const welcomePromise = new Promise(resolve =&gt; {  <br>console.log(\"In Promise executor fn\"); <br><br> resolve(\"Welcome!\");<br>}); </pre>\n<pre>console.log(\"Before calling the then method\");<br><br>welcomePromise.then(console.log); </pre>\n<pre>// console output:<br>// In Promise executor fn<br>// Before calling the then method<br>// Welcome!</pre>\n<p><strong>Observables</strong> is <strong>lazy</strong>\u00a0, since not executed until a consumer subscribes. The subscribe() executes the defined behavior once, and it can be called again. Each subscription has its own computation. Resubscription causes recomputation of\u00a0values.</p>\n<pre>import { Observable } from \"rxjs\";</pre>\n<pre>const welcomeObservable$ = new Observable(observer =&gt; {   console.log(\"In Observable producer fn\"); </pre>\n<pre>  observer.next(\"Welcome!\"); <br>  observer.complete();</pre>\n<pre>}); <br>console.log(\"Before calling the subscribe method\"); welcomeObservable$.subscribe(console.log); </pre>\n<pre>// console output:<br>// Before calling the subscribe method<br>// In Observable producer fn<br>// Welcome!</pre>\n<h3><strong>Async vs\u00a0Sync</strong></h3>\n<p>Even if immediately resolved, the <strong>Promise<em> </em>is always asynchronous.</strong></p>\n<pre>const welcomePromise = new Promise(resolve =&gt; {  <br>console.log(\"In Promise executor fn\"); <br><br> resolve(\"Welcome!\");<br>});</pre>\n<pre>console.log(\"Before calling the then method\");<br><br>welcomePromise.then(console.log);</pre>\n<pre>console.log(\"After calling the then method\"); </pre>\n<pre>// console output:<br>// In Promise executor fn<br>// Before calling the then method<br>// After calling the then method<br>// Welcome!</pre>\n<p>The <strong>Observables</strong> may be <strong>synchronous</strong> or <strong>asynchronous</strong></p>\n<p><strong>Synchronous</strong></p>\n<pre>import { Observable } from \"rxjs\";</pre>\n<pre>const welcomeObservable = new Observable(observer =&gt; {   console.log(\"In Observable producer fn\");</pre>\n<pre>observer.next(\"Welcome!\"); <br>  observer.complete();</pre>\n<pre>}); <br>console.log(\"Before calling the subscribe method\"); </pre>\n<pre>welcomeObservable.subscribe(console.log);</pre>\n<pre>// console output:<br>// Before calling the subscribe method<br>// In Observable producer fn<br>// Welcome!</pre>\n<p><strong>Asynchronous</strong></p>\n<pre>import { Observable } from \"rxjs\";</pre>\n<pre>const asyncObservable = new Observable(observer =&gt; {   console.log(\"In Observable producer fn\");</pre>\n<pre>setTimeout(() =&gt; {</pre>\n<pre>observer.next(\"Async!\"); <br>  observer.complete();</pre>\n<pre>} , 1000)</pre>\n<pre>}); <br>console.log(\"Before calling the subscribe method\");</pre>\n<pre>asyncObservable.subscribe(console.log);</pre>\n<pre>console.log(\"After calling the subscribe method\");</pre>\n<pre>// console output:<br>// Before calling the subscribe method<br>// In Observable producer fn<br>// After calling the subscribe method<br>// Async!</pre>\n<h3><strong>Single vs Multiple\u00a0values</strong></h3>\n<p><strong>Promises</strong> are most commonly used to handle HTTP requests. In this model, you make a request and then wait for a single response. You can be sure that there won\u2019t be multiple responses to the same\u00a0request.</p>\n<pre>const numberPromise = new Promise((resolve) =&gt; { <br>resolve(5);<br>});</pre>\n<pre> numberPromise.then(value =&gt; console.log(value));<br>// will simply print 5</pre>\n<p><strong>Promise</strong> is always resolved with the first value passed to the <strong>resolve</strong> function and ignores further calls to\u00a0it:</p>\n<pre>const numberPromise = new Promise((resolve) =&gt; { <br>resolve(5);<br>resolve(10);<br>});</pre>\n<pre>numberPromise.then(value =&gt; console.log(value));<br>// still prints only 5</pre>\n<p><strong>Observables</strong> allow you to resolve (or, as we say, \u201cemit\u201d) multiple\u00a0values.</p>\n<pre>const numberObservable = new Observable((observer) =&gt; {    observer.next(5);   <br>observer.next(10);<br>});</pre>\n<pre>numberObservable.subscribe(value =&gt; console.log(value));<br>// prints 5 and 10</pre>\n<h3>Cancellation</h3>\n<p><strong>Observable</strong> subscriptions are cancellable. Unsubscribing removes the listener from receiving further values, and notifies the subscriber function to cancel\u00a0work.</p>\n<pre>const subscription = observable.subscribe(() =&gt; {</pre>\n<pre>// observer handles notifications</pre>\n<pre>});</pre>\n<pre>subscription.unsubscribe();</pre>\n<h4>\n<strong>Promises</strong> are not cancellable.</h4>\n<h3>Conclusions</h3>\n<p>There are many differences between Observable and Promise. But the main differences are\u00a0:</p>\n<ul>\n<li>The Observable<em> </em>is lazy whereas the Promise<em> </em>is\u00a0eager</li>\n<li>The Promise<em> </em>is always asynchronous, while the Observable<em> </em>can be either asynchronous or synchronous</li>\n<li>The Promise<em> </em>can emit only a single value, whereas the Observable<em> </em>can emit single<em> or </em>multiple\u00a0values.</li>\n<li>The Observable<em> </em>subscriptions are cancellable whereas Promises are not cancellable.</li>\n</ul>\n<p>Thank you, for reading this post\u00a0, hope you liked it please give an applause.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7c1af6fefd12\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*A09g76kdTMW6XOSEbTXw3w.jpeg\"></figure><p>There has been an on-going debate in the world of developers, and that is which is better: JavaScript <strong>Promises</strong> or RxJS <strong>Observables</strong>? Each one can bring so much value to different projects. It\u2019s a good idea to have a good understanding of each and how it could benefit a project. But before we start looking at some comparisons, let\u2019s do a quick overview of what each one\u00a0is.</p>\n<h3><strong>What is a\u00a0Promise</strong></h3>\n<p>A <strong><em>promise</em></strong> is an object that encapsulates the result of an asynchronous operation.</p>\n<p>Each promise has state, which can have one of the following values:</p>\n<ul>\n<li><em>Pending</em></li>\n<li>\n<em>Fulfilled</em> with a\u00a0value</li>\n<li>\n<em>Rejected</em> for a\u00a0reason</li>\n</ul>\n<p>The just created promise is in a <em>pending</em> state. The promise maintains the <em>pending</em> state as long as the asynchronous operation behind is in progress.</p>\n<p>Then, depending on how the asynchronous operation completes, the promise state changes to\u00a0either:</p>\n<p>A) <em>fulfilled</em> (when the async operation completed successfully)</p>\n<p>B) or <em>rejected</em> (when then async operation failed).</p>\n<p>In JavaScript, you can create a promise object using a special constructor</p>\n<pre>const promise = new Promise((resolve, reject) =&gt; {<br>  // Async operation logic here....<br>  if (asyncOperationSuccess) {<br>    resolve(value); // async operation successful<br>  } else {<br>    reject(error);  // async operation error<br>  }<br>});</pre>\n<h3><strong>What is Observable</strong></h3>\n<p><strong><em>Observable</em></strong> are just that\u200a\u2014\u200athings you wish to observe and take action on. Angular uses the <strong>Observer pattern</strong> which simply means\u200a\u2014\u200aObservable objects are registered, and other objects observe (in Angular using the subscribe method) them and take action when the observable object is acted on in some\u00a0way.</p>\n<p>To use observable, Angular uses a third-party library called Reactive Extensions (<strong>RxJS</strong>).</p>\n<p>Let\u2019s take a look how can we use <strong><em>Observable</em></strong> in our Angular application.</p>\n<pre>import { Observable } from 'rxjs/Observable';</pre>\n<pre>// Create simple observable that emits three values <br>   const myObservable = Observable.of(1, 2, 3); </pre>\n<pre>// Create observer object <br>   const myObserver = { <br>next: x =&gt; console.log('Observer got a next value: ' + x),             error: err =&gt; console.error('Observer got an error: ' + err),          complete: () =&gt; console.log('Observer got a complete notification')<br> };         </pre>\n<pre>// Execute with the observer object    myObservable.subscribe(myObserver);  </pre>\n<pre>  // Logs:   <br> // Observer got a next value: 1   <br> // Observer got a next value: 2    <br>// Observer got a next value: 3    <br>// Observer got a complete notification</pre>\n<p>Here are the main differences which is covered in this blog\u00a0post:</p>\n<h3>Eager vs\u00a0Lazy</h3>\n<p><strong>Promise is eager\u00a0, </strong>hence<strong> </strong>execute immediately, and just once. The computation of the result is initiated when the promise is created. There is no way to restart work. All then clauses (subscriptions) share the same computation.</p>\n<pre>const welcomePromise = new Promise(resolve =&gt; {  <br>console.log(\"In Promise executor fn\"); <br><br> resolve(\"Welcome!\");<br>}); </pre>\n<pre>console.log(\"Before calling the then method\");<br><br>welcomePromise.then(console.log); </pre>\n<pre>// console output:<br>// In Promise executor fn<br>// Before calling the then method<br>// Welcome!</pre>\n<p><strong>Observables</strong> is <strong>lazy</strong>\u00a0, since not executed until a consumer subscribes. The subscribe() executes the defined behavior once, and it can be called again. Each subscription has its own computation. Resubscription causes recomputation of\u00a0values.</p>\n<pre>import { Observable } from \"rxjs\";</pre>\n<pre>const welcomeObservable$ = new Observable(observer =&gt; {   console.log(\"In Observable producer fn\"); </pre>\n<pre>  observer.next(\"Welcome!\"); <br>  observer.complete();</pre>\n<pre>}); <br>console.log(\"Before calling the subscribe method\"); welcomeObservable$.subscribe(console.log); </pre>\n<pre>// console output:<br>// Before calling the subscribe method<br>// In Observable producer fn<br>// Welcome!</pre>\n<h3><strong>Async vs\u00a0Sync</strong></h3>\n<p>Even if immediately resolved, the <strong>Promise<em> </em>is always asynchronous.</strong></p>\n<pre>const welcomePromise = new Promise(resolve =&gt; {  <br>console.log(\"In Promise executor fn\"); <br><br> resolve(\"Welcome!\");<br>});</pre>\n<pre>console.log(\"Before calling the then method\");<br><br>welcomePromise.then(console.log);</pre>\n<pre>console.log(\"After calling the then method\"); </pre>\n<pre>// console output:<br>// In Promise executor fn<br>// Before calling the then method<br>// After calling the then method<br>// Welcome!</pre>\n<p>The <strong>Observables</strong> may be <strong>synchronous</strong> or <strong>asynchronous</strong></p>\n<p><strong>Synchronous</strong></p>\n<pre>import { Observable } from \"rxjs\";</pre>\n<pre>const welcomeObservable = new Observable(observer =&gt; {   console.log(\"In Observable producer fn\");</pre>\n<pre>observer.next(\"Welcome!\"); <br>  observer.complete();</pre>\n<pre>}); <br>console.log(\"Before calling the subscribe method\"); </pre>\n<pre>welcomeObservable.subscribe(console.log);</pre>\n<pre>// console output:<br>// Before calling the subscribe method<br>// In Observable producer fn<br>// Welcome!</pre>\n<p><strong>Asynchronous</strong></p>\n<pre>import { Observable } from \"rxjs\";</pre>\n<pre>const asyncObservable = new Observable(observer =&gt; {   console.log(\"In Observable producer fn\");</pre>\n<pre>setTimeout(() =&gt; {</pre>\n<pre>observer.next(\"Async!\"); <br>  observer.complete();</pre>\n<pre>} , 1000)</pre>\n<pre>}); <br>console.log(\"Before calling the subscribe method\");</pre>\n<pre>asyncObservable.subscribe(console.log);</pre>\n<pre>console.log(\"After calling the subscribe method\");</pre>\n<pre>// console output:<br>// Before calling the subscribe method<br>// In Observable producer fn<br>// After calling the subscribe method<br>// Async!</pre>\n<h3><strong>Single vs Multiple\u00a0values</strong></h3>\n<p><strong>Promises</strong> are most commonly used to handle HTTP requests. In this model, you make a request and then wait for a single response. You can be sure that there won\u2019t be multiple responses to the same\u00a0request.</p>\n<pre>const numberPromise = new Promise((resolve) =&gt; { <br>resolve(5);<br>});</pre>\n<pre> numberPromise.then(value =&gt; console.log(value));<br>// will simply print 5</pre>\n<p><strong>Promise</strong> is always resolved with the first value passed to the <strong>resolve</strong> function and ignores further calls to\u00a0it:</p>\n<pre>const numberPromise = new Promise((resolve) =&gt; { <br>resolve(5);<br>resolve(10);<br>});</pre>\n<pre>numberPromise.then(value =&gt; console.log(value));<br>// still prints only 5</pre>\n<p><strong>Observables</strong> allow you to resolve (or, as we say, \u201cemit\u201d) multiple\u00a0values.</p>\n<pre>const numberObservable = new Observable((observer) =&gt; {    observer.next(5);   <br>observer.next(10);<br>});</pre>\n<pre>numberObservable.subscribe(value =&gt; console.log(value));<br>// prints 5 and 10</pre>\n<h3>Cancellation</h3>\n<p><strong>Observable</strong> subscriptions are cancellable. Unsubscribing removes the listener from receiving further values, and notifies the subscriber function to cancel\u00a0work.</p>\n<pre>const subscription = observable.subscribe(() =&gt; {</pre>\n<pre>// observer handles notifications</pre>\n<pre>});</pre>\n<pre>subscription.unsubscribe();</pre>\n<h4>\n<strong>Promises</strong> are not cancellable.</h4>\n<h3>Conclusions</h3>\n<p>There are many differences between Observable and Promise. But the main differences are\u00a0:</p>\n<ul>\n<li>The Observable<em> </em>is lazy whereas the Promise<em> </em>is\u00a0eager</li>\n<li>The Promise<em> </em>is always asynchronous, while the Observable<em> </em>can be either asynchronous or synchronous</li>\n<li>The Promise<em> </em>can emit only a single value, whereas the Observable<em> </em>can emit single<em> or </em>multiple\u00a0values.</li>\n<li>The Observable<em> </em>subscriptions are cancellable whereas Promises are not cancellable.</li>\n</ul>\n<p>Thank you, for reading this post\u00a0, hope you liked it please give an applause.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7c1af6fefd12\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["blog","javascript","writing","angular"]}]}